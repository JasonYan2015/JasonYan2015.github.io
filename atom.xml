<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AjunSpace</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jasonyan2015.github.io/"/>
  <updated>2017-04-02T04:01:01.853Z</updated>
  <id>https://jasonyan2015.github.io/</id>
  
  <author>
    <name>Ajun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://jasonyan2015.github.io/2017/04/04/JSc/"/>
    <id>https://jasonyan2015.github.io/2017/04/04/JSc/</id>
    <published>2017-04-04T02:15:55.878Z</published>
    <updated>2017-04-02T04:01:01.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Js跨域"><a href="#Js跨域" class="headerlink" title="Js跨域"></a>Js跨域</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><h5 id="同源包括三个相同"><a href="#同源包括三个相同" class="headerlink" title="同源包括三个相同"></a>同源包括三个相同</h5><ul>
<li>协议（protocol）相同</li>
<li>域名（domain/host）相同</li>
<li>端口（port）相同</li>
</ul>
<p>举例来说，对于<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。</p>
<ul>
<li><a href="http://www.example.com/dir2/other.html：同源" target="_blank" rel="external">http://www.example.com/dir2/other.html：同源</a></li>
<li><a href="http://example.com/dir/other.html：不同源（域名不同）" target="_blank" rel="external">http://example.com/dir/other.html：不同源（域名不同）</a></li>
<li><a href="http://v2.www.example.com/dir/other.html：不同源（域名不同）" target="_blank" rel="external">http://v2.www.example.com/dir/other.html：不同源（域名不同）</a></li>
<li><a href="http://www.example.com:81/dir/other.html：不同源（端口不同）" target="_blank" rel="external">http://www.example.com:81/dir/other.html：不同源（端口不同）</a></li>
</ul>
<p>更多例子：</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>说明</th>
<th>是否允许通信</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td>同一域名下</td>
<td>允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/lab/a.js" target="_blank" rel="external">http://www.a.com/lab/a.js</a><br><a href="http://www.a.com/script/b.js" target="_blank" rel="external">http://www.a.com/script/b.js</a></td>
<td>同一域名下不同文件夹</td>
<td>允许</td>
</tr>
<tr>
<td><a href="http://www.a.com:8000/a.js" target="_blank" rel="external">http://www.a.com:8000/a.js</a><br><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td>同一域名，不同端口</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="https://www.a.com/b.js" target="_blank" rel="external">https://www.a.com/b.js</a></td>
<td>同一域名，不同协议</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://70.32.92.74/b.js" target="_blank" rel="external">http://70.32.92.74/b.js</a></td>
<td>域名和域名对应ip</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://script.a.com/b.js" target="_blank" rel="external">http://script.a.com/b.js</a></td>
<td>主域相同，子域不同</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://a.com/b.js" target="_blank" rel="external">http://a.com/b.js</a></td>
<td>同一域名，不同二级域名（同上）</td>
<td>不允许（cookie这种情况下也不允许访问）</td>
</tr>
<tr>
<td><a href="http://www.cnblogs.com/a.js" target="_blank" rel="external">http://www.cnblogs.com/a.js</a><br><a href="http://a.com/b.js" target="_blank" rel="external">http://a.com/b.js</a></td>
<td>不同域名</td>
<td>不允许</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意</p>
<ol>
<li>如果是协议和端口造成的跨域问题“前台”是无能为力的，</li>
<li>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。</li>
</ol>
<blockquote>
<p>“URL的首部”指<code>window.location.protocol</code> + <code>window.location.host</code>，也可以理解为“Domains, protocols and ports must match”。</p>
</blockquote>
</blockquote>
<h5 id="同源策略的目的"><a href="#同源策略的目的" class="headerlink" title="同源策略的目的"></a>同源策略的目的</h5><p>为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<h5 id="受限制的行为"><a href="#受限制的行为" class="headerlink" title="受限制的行为"></a>受限制的行为</h5><ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li>DOM 无法获得。</li>
<li>AJAX 请求不能发送。</li>
</ul>
<h3 id="cookie跨域"><a href="#cookie跨域" class="headerlink" title="cookie跨域"></a>cookie跨域</h3><p>Cookie 是服务器写入浏览器的一小段信息，是储存在用户本地终端上的数据，通常被用来记录访问者的一些信息（尽管这并不安全），只有同源的网页才能共享。</p>
<p>不过这个共享范围比同源稍宽松些。</p>
<p>如果两个网页一级域名相同，只是二级域名不同，那么浏览器允许通过设置document.domain来共享 Cookie。</p>
<p>例如：</p>
<ol>
<li>对A,B网页同时设置：<code>document.domain = &#39;example.com&#39;;</code></li>
<li>在A网页中通过脚本设置一个Cookie：<code>document.cookie = &quot;test1=hello&quot;;</code></li>
<li>B网页就可以读到这个 Cookie：<code>var allCookie = document.cookie;</code></li>
</ol>
<blockquote>
<p>注意：这种方法只适用于 Cookie 和 iframe 窗口（下一节会谈到），LocalStorage 和 IndexDB 无法通过这种方法规避同源政策，而要使用下文介绍的PostMessage API。</p>
<p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如为<code>.example.com</code>设置<code>Set-Cookie: key=value; domain=.example.com; path=/</code>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>
</blockquote>
<h3 id="iframe跨域"><a href="#iframe跨域" class="headerlink" title="iframe跨域"></a>iframe跨域</h3><p>如果两个网页不同源，就无法拿到对方的DOM。<br>典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p>
<pre><code>document.getElementById(&quot;myIFrame&quot;).contentWindow.document
// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.
</code></pre><p>上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。<br>反之亦然，子窗口获取主窗口的DOM也会报错。</p>
<pre><code>window.parent.document.body
// 报错
</code></pre><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><ol>
<li><p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源策略来访问DOM。</p>
<p> 举例如下</p>
<p> 在a.html中</p>
<pre><code>document.domain = &apos;a.com&apos;;
var ifr = document.createElement(&apos;iframe&apos;);
ifr.src = &apos;http://script.a.com/b.html&apos;;
ifr.style.display = &apos;none&apos;;
document.body.appendChild(ifr);
ifr.onload = function(){
    var doc = ifr.contentDocument || ifr.contentWindow.document;
    // 在这里操纵b.html
    alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);
};
</code></pre><p> b.html中</p>
<pre><code>document.domain = &apos;a.com&apos;;
</code></pre></li>
<li><p>对于完全不同源的网站，目前有以下几种方法可以解决跨域窗口的通信问题</p>
<ol>
<li>片段识别符（fragment identifier）</li>
<li><p>window.name</p>
<ol>
<li>跨文档通信API（Cross-document messaging）</li>
</ol>
<h5 id="片段标识符"><a href="#片段标识符" class="headerlink" title="片段标识符"></a>片段标识符</h5><p>片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如<code>http://example.com/x.html#fragment的#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<p> var src = originURL + ‘#’ + data;<br> document.getElementById(‘myIFrame’).src = src;</p>
<p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>
<p> window.onhashchange = checkMessage;</p>
<p> function checkMessage() {<br>   var message = window.location.hash;<br>   // …<br> }</p>
<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<p> parent.location.href= target + “#” + hash;</p>
<h5 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h5><p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<p>有三个页面：</p>
</li>
</ol>
<ul>
<li>a.com/app.html：应用页面。</li>
<li>a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。</li>
<li><p>b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。</p>
<p>过程如下：</p>
</li>
</ul>
<ol>
<li><p>在应用页面<code>（a.com/app.html）</code>中创建一个<code>iframe</code>，把其<code>src</code>指向数据页面<code>（b.com/data.html）</code>。数据页面<code>（b.com/data.html）</code>设置window.name时，由于同源，会自动把数据附加到这个<code>iframe</code>的<code>window.name</code>上，代码如下：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
        window.name = &apos;I was there!&apos;;    //这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右。
                                         //数据格式可以自定义，如json、字符串
&lt;/script&gt;
</code></pre></li>
<li><p>在应用页面<code>（a.com/app.html）</code>中监听<code>iframe</code>的<code>onload</code>事件，在此事件中设置这个<code>iframe</code>的<code>src</code>指向本地域的代理文件（代理文件和应用页面在同一域下，所以可以相互通信）。app.html部分代码如下：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var state = 0, 
    iframe = document.createElement(&apos;iframe&apos;),
    loadfn = function() {
        if (state === 1) {
            var data = iframe.contentWindow.name;    // 读取数据
            alert(data);    //弹出&apos;I was there!&apos;
        } else if (state === 0) {
            state = 1;
            iframe.contentWindow.location = &quot;http://a.com/proxy.html&quot;;    // 设置的代理文件，此时由于iframe的loaction改变，又一次触发load事件
        }  
    };
    iframe.src = &apos;http://b.com/data.html&apos;;
    if (iframe.attachEvent) {
        iframe.attachEvent(&apos;onload&apos;, loadfn);
    } else {
        iframe.onload  = loadfn;
    }
    document.body.appendChild(iframe);
&lt;/script&gt;
</code></pre></li>
<li><p>获取数据以后销毁这个<code>iframe</code>，释放内存；这也保证了安全（不被其他域frame js访问）。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    iframe.contentWindow.document.write(&apos;&apos;);
    iframe.contentWindow.close();
    document.body.removeChild(iframe);
&lt;/script&gt;
</code></pre><p>总结起来即：iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<p>优点是，window.name容量很大，可以放置非常长的字符串；<br>缺点是，必须监听子窗口window.name属性的变化，影响网页性能。</p>
<h5 id="跨文档通信API–postMessage"><a href="#跨文档通信API–postMessage" class="headerlink" title="跨文档通信API–postMessage()"></a>跨文档通信API–postMessage()</h5><p>HTML5新增一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。并且支持基于web的实时消息传递。</p>
<p>otherWindow.postMessage(message, targetOrigin);</p>
</li>
</ol>
<ul>
<li><code>otherWindow</code>: 对接收信息页面的window的引用。可以是页面中<code>iframe</code>的<code>contentWindow</code>属性；<code>window.open</code>的返回值；通过<code>name</code>或下标从<code>window.frames</code>取到的值。</li>
<li><code>message</code>: 所要发送的数据，string类型。</li>
<li><p><code>targetOrigin</code>: 用于限制otherWindow，即”协议 + 域名 + 端口”，<code>*</code>表示不限制域名，向所有窗口发送</p>
<p>举例来说，父窗口<code>http://aaa.com</code>与子窗口<code>http://bbb.com</code>互发消息</p>
<p>父-&gt;子</p>
<p>  var popup = window.open(‘<a href="http://bbb.com" target="_blank" rel="external">http://bbb.com</a>‘, ‘title’);<br>  popup.postMessage(‘Hello World!’, ‘<a href="http://bbb.com" target="_blank" rel="external">http://bbb.com</a>‘);</p>
<p>子-&gt;父</p>
<p>  window.opener.postMessage(‘Nice to see you’, ‘<a href="http://aaa.com" target="_blank" rel="external">http://aaa.com</a>‘);</p>
<p>接受消息：message事件</p>
<p>  window.addEventListener(‘message’, function(e) {</p>
<pre><code>console.log(e.data);
</code></pre><p>  },false);</p>
<p><code>message</code>事件的事件对象<code>event</code>，提供以下三个属性。</p>
</li>
<li><p>event.source：发送消息的窗口</p>
</li>
<li>event.origin: 消息发向的网址</li>
<li><p>event.data: 消息内容</p>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<p>  window.addEventListener(‘message’, receiveMessage);<br>  function receiveMessage(event) {</p>
<pre><code>event.source.postMessage(&apos;Nice to see you!&apos;, &apos;*&apos;);
</code></pre><p>  }</p>
<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<p>  window.addEventListener(‘message’, receiveMessage);<br>  function receiveMessage(event) {</p>
<pre><code>if (event.origin !== &apos;http://aaa.com&apos;) return;
if (event.data === &apos;Hello World&apos;) {
    event.source.postMessage(&apos;Hello&apos;, event.origin);
} else {
  console.log(event.data);
}
</code></pre><p>  }</p>
</li>
</ul>
</li>
</ol>
<h3 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h3><p>同源政策规定，AJAX请求只能发给同源的网址。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<p>它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>
<p>举个例子</p>
<pre><code>function addScriptTag(src) {
  var script = document.createElement(&apos;script&apos;);
  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
  script.src = src;
  document.body.appendChild(script);
}

window.onload = function () {
  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);
}

function foo(data) {
  console.log(&apos;Your public IP address is: &apos; + data.ip);
};
</code></pre><p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。</p>
<blockquote>
<p>注意：该请求的查询字符串有一个<code>callback</code>参数（在服务器中须对其进行相关声明和定义），用来指定回调函数的名字，这对于JSONP是必需的。假设目标返回的数据是<code>[&quot;customername1&quot;,&quot;customername2&quot;]</code>那么真正返回到客户端的数据为<code>foo([&quot;customername1&quot;,&quot;customername2&quot;])</code></p>
</blockquote>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h3 id="WebSocket跨域"><a href="#WebSocket跨域" class="headerlink" title="WebSocket跨域"></a>WebSocket跨域</h3><p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的WebSocket请求的头信息</p>
<pre><code>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
</code></pre><p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<pre><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h3><p>跨源资源分享（Cross-Origin Resource Sharing）</p>
<p>它是W3C标准，是跨源AJAX请求的根本解决方法。</p>
<p>相比JSONP只能发GET请求，CORS允许任何类型的请求。</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">CORS跨域详情</a></p>
<hr>
<p>参考链接</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">浏览器同源政策及其规避方法</a></p>
<p><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="external">JavaScript跨域总结与解决办法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Js跨域&quot;&gt;&lt;a href=&quot;#Js跨域&quot; class=&quot;headerlink&quot; title=&quot;Js跨域&quot;&gt;&lt;/a&gt;Js跨域&lt;/h2&gt;&lt;h3 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://jasonyan2015.github.io/2017/04/03/hello-world/"/>
    <id>https://jasonyan2015.github.io/2017/04/03/hello-world/</id>
    <published>2017-04-03T12:27:13.561Z</published>
    <updated>2017-04-03T14:47:51.470Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
